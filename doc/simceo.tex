% ===> this file was generated automatically by noweave --- better not edit it
\section{Introduction}
\label{sec:introduction}

% This documents describes SIMCEO, an interface between CEO and Simulink.
% SIMCEO allows to seamlessly integrates CEO functionalities into a Simulink model.
% A Simulink library, \emph{CEO}, provides a set of blocks that are used to instantiate CEO objects.
% The blocks either send data to the CEO objects updating the state of these objects, or query data from the CEO objects.
% The data received from the CEO objects is then forwarded to the other blocks of the Simulink model. 

\section{Installation}
\label{sec:installation}

% This section describes the installation of the SIMCEO client i.e. the Matlab and Simulink part of SIMCEO.

% To install SIMCEO on your computer, creates a directory \texttt{SIMCEO}, downloads the archive \texttt{simceo.zip} and extracts it in the \texttt{SIMCEO} directory.

% In addition to Matlab and Simulink, the client relies of aws cli, ZeroMQ and UBJSON.

% \subsection{AWS command line interface}
% \label{sec:aws-cli}

% The AWS command line interface (\texttt{aws cli}) allows to launch/terminate and to start/stop the AWS instances where the SIMCEO server resides.
% To install it, follows the instructions at \\ \url{http://docs.aws.amazon.com/cli/latest/userguide/installing.html} \\
% Once installed, open a terminal and at the shell prompt enter: \\\texttt{>> aws configure --profile gmto.control}\\ and answers the questions using the \texttt{gmto.control.credentials} file provided separately.

% At Matlab prompt enter: \texttt{>> system('aws --version')}.
% If Matlab cannot find \texttt{aws}, replace \texttt{aws} in \texttt{etc/simceo.json} by the full path to \texttt{aws}.

% \subsection{Matlab--ZMQ}
% \label{sec:zeromq}

% Matlab--ZMQ\footnote{\url{https://github.com/fagg/matlab-zmq}} is a Matlab wrapper for ZeroMQ.
% ZeroMQ \footnote{\url{http://zeromq.org/}} is the messaging library used for the communications between SIMCEO client and server.
% Both Matlab--ZMQ and ZeroMQ are shipped pre--compiled with SIMCEO. 
% You need however to add, to the Matlab search path, the path t o ZeroMQ.
% To do so, move Matlab current folder to SIMCEO folder and at the Matlab prompt enter:
% \\\texttt{>> addpath([pwd,'/matlab-zmq/your-os/lib/'])}\\\texttt{>> savepath}\\
% where \texttt{your-os} is either \texttt{unix}, \texttt{mac} \texttt{windows7} or \texttt{windows10}.

% \subsection{UBJSON}
% \label{sec:ubjson}

% Universal Binary JSON (UBJSON\footnote{\url{http://ubjson.org/}}) is the message format used toTapio.Helin@lut.fi exchanumpynge data between SIMCEO client and server.
% The Matlab UBJSON encoder and decoder is JSONLAB.
% SIMCEO comes with its own version of JSONLAB that fixes a few bugs.
% To add JSONLAB to the Matlab search path, move Matlab current folder to SIMCEO folder and at the Matlab prompt enter:
% \\\texttt{>> addpath([pwd,'/jsonlab/'])}\\\texttt{>> savepath}\\

\section{Implementation}
\label{sec:implementation}

% The interface between CEO and Simulink has two components a Matlab package \emph{ceo} on the user computer, the client, and a python module \emph{simulink} on a CEO AWS instance, the server.
% A flowchart of SIMCEO is shown in Fig.~\ref{simceo-flowchart}.
% The Matlab package is written with custom blocks using a \emph{Level--2 Matlab S--function}.
% A \emph{Level--2 Matlab S--function} consists in a collection of functions that are called by the Simulink engine when a model is running.
% Inside the \emph{Level--2 Matlab S--function}, the functions \emph{Start}, \emph{Terminate} and \emph{Outputs} are used to exchange information with CEO.
% The Matlab class \emph{broker}  Acknowledging connection to SIMCEO serveris responsible for starting the CEO server in the AWS cloud and for managing the communication with the server.

% The requests from the client are managed by the \emph{broker} class of the \emph{simulink} python module on the server.
% The \emph{simulink} module is providing three python classes to deal with Simulink requests: \emph{SGMT}, \emph{SAtmosphere} and \emph{SOpticalPath}.

% The communication between the client and the server uses the Request/Reply messaging pattern of ZeroMQ.
% The messages exchanged between the client and the server are formatted according to the UBJSON format.

% \begin{figure}
%   \label{simceo-flowchart}
%   \centering
%   \input{simceo.flowchart.tex}    
%   \caption{SIMCEO flowchart.}
% \end{figure}

\section{The python server module}
\label{sec:simul-pyth-module}

% \begin{figure}
%   \centering
%   \includegraphics[width=\linewidth]{simulink.png}
%   \caption{The classes in the simulink python module and their relations with the CEO classes.}
% \end{figure}

The python interface consists in the module \emph{simulink}:
\nwfilename{simceo.nw}\nwbegincode{1}\sublabel{NW4Bsmdy-3TXSTG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3TXSTG-1}}}\moddef{simceo.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-3TXSTG-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
import sys
import threading
import time
import zmq
import ceo
import numpy as np
from collections import OrderedDict
import os
import shelve
import traceback
import scipy.linalg as LA
import pickle
import zlib
import logging
import copy
from numpy.linalg import norm

logging.basicConfig()

try:
    from Telescope import FEM, WindLoad
except:
    logging.warning('Telescope package not found!')


SIMCEOPATH = os.path.abspath(os.path.dirname(__file__))

class testComm:
    def __init__(self):
        pass
    def hello(self,N=1):
        data = np.ones(N)
        return dict(data=data.tolist())

class Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print('[%s]' % self.name)
        print('Elapsed time: %s' % (time.time() - self.tstart))

\LA{}CalibrationMatrix~{\nwtagstyle{}\subpageref{NW4Bsmdy-3jZIZN-1}}\RA{}

\LA{}S-function~{\nwtagstyle{}\subpageref{NW4Bsmdy-3Fygjc-1}}\RA{}

\LA{}SGMT~{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-1}}\RA{}
\LA{}SAtmosphere~{\nwtagstyle{}\subpageref{NW4Bsmdy-4UUQgn-1}}\RA{}
\LA{}SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}\RA{}

\LA{}broker~{\nwtagstyle{}\subpageref{NW4Bsmdy-2zgnz8-1}}\RA{}

if __name__ == "__main__":

    print("*********************************")
    print("**   STARTING SIMCEO SERVER    **")
    print("*********************************")
    args = sys.argv[1:]
    verbose = int(args[0]) if args else logging.INFO
    agent = broker(verbose=verbose)
    agent.start()
 
\nwnotused{simceo.py}\nwendcode{}\nwbegindocs{2}\nwdocspar

\subsection{The broker class}
\label{sec:broker-class}

% There are two broker classes, one written with python and acting as the CEO server, and the other is the Simulink client written with Matlab.

% \subsubsection{CEO server}
% \label{sec:ceo-server}

The broker class receives requests from the Simulink S--functions, processes the requests and sends a replies to the Simulink client.
%The broker class is the CEO server.
%It replies to requests received from the Simulink S--functions.
%It relies on ZeroMQ to send and receive messages to and from a Simulink model.
It inherits from the \emph{threading.Thread} class.
\nwenddocs{}\nwbegincode{3}\sublabel{NW4Bsmdy-2zgnz8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2zgnz8-1}}}\moddef{broker~{\nwtagstyle{}\subpageref{NW4Bsmdy-2zgnz8-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwenddeflinemarkup
class broker(threading.Thread):

    def __init__(self, verbose=logging.INFO):

        threading.Thread.__init__(self)

        self.logger = logging.getLogger(self.__class__.__name__)
        self.verbose = verbose
        self.logger.setLevel(self.verbose)

        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.REP)
        self.address = "tcp://*:3650"
        self.socket.bind(self.address)
        self.loop = True
        
        self.ops = []
        self.n_op = 0
        self.currentTime = 0.0
        self.satm = SAtmosphere(self.ops,verbose=self.verbose)
        self.sgmt = SGMT(self.ops, self.satm, verbose=self.verbose)

    def __del__(self):

        self.release()

    def release(self):

        self.socket.close()
        self.context.term()

    def _send_(self,obj,protocol=-1,flags=0):
        pobj = pickle.dumps(obj,protocol)
        zobj = zlib.compress(pobj)
        self.socket.send(zobj, flags=flags)

    def _recv_(self,flags=0):
        zobj = self.socket.recv(flags)
        pobj = zlib.decompress(zobj)
        return pickle.loads(pobj)

    \LA{}broker get item~{\nwtagstyle{}\subpageref{NW4Bsmdy-2erBDY-1}}\RA{}

    \LA{}broker run~{\nwtagstyle{}\subpageref{NW4Bsmdy-2eBAe0-1}}\RA{}
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{4}\nwdocspar
The \emph{run} method 
\nwenddocs{}\nwbegincode{5}\sublabel{NW4Bsmdy-2eBAe0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2eBAe0-1}}}\moddef{broker run~{\nwtagstyle{}\subpageref{NW4Bsmdy-2eBAe0-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2zgnz8-1}}\nwenddeflinemarkup
def run(self):
    
    while self.loop:

        \LA{}broker run details~{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-1}}\RA{}
\nwused{\\{NW4Bsmdy-2zgnz8-1}}\nwendcode{}\nwbegindocs{6}\nwdocspar
waits for a request from a Simulink S--function:
\nwenddocs{}\nwbegincode{7}\sublabel{NW4Bsmdy-PmwVg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-1}}}\moddef{broker run details~{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2eBAe0-1}}\nwprevnextdefs{\relax}{NW4Bsmdy-PmwVg-2}\nwenddeflinemarkup
#jmsg = ubjson.loadb(msg)
msg = ''
try:
    self.logger.debug('Waiting for message ...')
    #msg = self.socket.recv()
    #jmsg = ubjson.loadb(msg)
    msg = self._recv_()
    self.logger.debug('Received: %s',msg)
except Exception as E:
    #print("Error raised by ubjson.loadb by that does not stop us!")
    print(msg)
    raise
\nwalsodefined{\\{NW4Bsmdy-PmwVg-2}\\{NW4Bsmdy-PmwVg-3}\\{NW4Bsmdy-PmwVg-4}}\nwused{\\{NW4Bsmdy-2eBAe0-1}}\nwendcode{}\nwbegindocs{8}\nwdocspar
The message received from the S--function contains
\begin{itemize}
\item the Simulink simulation time \emph{currentTime},
\item a class identifier, \emph{class\_id}: \textbf{GMT} for \emph{SGMT}, \textbf{ATM} for \emph{SAtmosphere} or \textbf{OP} for \emph{SOpticalPath},
\item a method identifier, \emph{method\_id}: \textbf{Start}, \textbf{Terminate}, \textbf{Update} or \textbf{Outputs},
\item a dictionnary of the arguments to the method,  \emph{args}.
\end{itemize}
The class method is invoked with:
\nwenddocs{}\nwbegincode{9}\sublabel{NW4Bsmdy-PmwVg-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-2}}}\moddef{broker run details~{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2eBAe0-1}}\nwprevnextdefs{NW4Bsmdy-PmwVg-1}{NW4Bsmdy-PmwVg-3}\nwenddeflinemarkup
#self.currentTime = float( jmsg["currentTime"][0][0] )
if not 'class_id' in msg:
    self._send_("SIMCEO server received: \{\}".format(msg))
    continue
class_id  = msg["class_id"]
method_id = msg["method_id"]
self.logger.debug('Calling out: %s.%s',class_id,method_id)
#print "@ %.3fs: %s->%s"%(currentTime,jmsg["tag"],method_id)
#tid = ceo.StopWatch()
try:
    #tid.tic()
    args_out = getattr( self[class_id], method_id )( **msg["args"] )
    #tid.toc()
    #print "%s->%s: %.2f"%(class_id,method_id,tid.elapsedTime) 
except Exception as E:
    print("@(broker)> The server has failed!")
    print(msg)
    traceback.print_exc()
    print("@(broker)> Recovering gracefully...")
    class_id = ""
    args_out = "The server has failed!"
\nwused{\\{NW4Bsmdy-2eBAe0-1}}\nwendcode{}\nwbegindocs{10}\nwdocspar
The dictionary--like call is implemented with 
\nwenddocs{}\nwbegincode{11}\sublabel{NW4Bsmdy-2erBDY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2erBDY-1}}}\moddef{broker get item~{\nwtagstyle{}\subpageref{NW4Bsmdy-2erBDY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2zgnz8-1}}\nwenddeflinemarkup
def __getitem__(self,key):
    if key=="GMT":
        return self.sgmt
    elif key=="ATM":
        return self.satm
    elif key[:2]=="OP":
        if key[2:]:
            op_idx = int(key[2:]) - self.n_op + len(self.ops)
            return self.ops[op_idx]
        else:
            self.ops.append( SOpticalPath( len(self.ops) ,
                                           self.sgmt.gmt ,
                                           self.satm.atm ,
                                           verbose=self.verbose) )            
            self.n_op = len(self.ops)
            return self.ops[-1]
    elif key=='testComm':
        return testComm()
    elif key=="FEM":
        if not hasattr(self,'fem'):
            self.fem = FEM()
        return self.fem
    elif key=="WindLoad":
        if not hasattr(self,'winds'):
            self.winds = WindLoad()
        return self.winds
    else:
        raise KeyError("Available keys are: GMT, ATM or OP")
\nwused{\\{NW4Bsmdy-2zgnz8-1}}\nwendcode{}\nwbegindocs{12}\nwdocspar
Each optical paths that is defined in the Simulink model is affected an unique ID tag made of the string \textbf{OP} followed by the index of the object in the optical path list \emph{ops}.
If the ID tag of the optical path is just \textbf{OP}, a new \emph{SOpticalPath} object is instanciated and appended to the list of optical path.

When the \emph{Terminate} method of an \emph{SOpticalPath} object is called, the object is removed from the optical path list \emph{ops}. 
\nwenddocs{}\nwbegincode{13}\sublabel{NW4Bsmdy-PmwVg-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-3}}}\moddef{broker run details~{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2eBAe0-1}}\nwprevnextdefs{NW4Bsmdy-PmwVg-2}{NW4Bsmdy-PmwVg-4}\nwenddeflinemarkup
if class_id[:2]=="OP" and method_id=="Terminate":
    self.ops.pop(0)
\nwused{\\{NW4Bsmdy-2eBAe0-1}}\nwendcode{}\nwbegindocs{14}\nwdocspar
The value return by the method of the invoked object is sent back to the S--function:
\nwenddocs{}\nwbegincode{15}\sublabel{NW4Bsmdy-PmwVg-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-4}}}\moddef{broker run details~{\nwtagstyle{}\subpageref{NW4Bsmdy-PmwVg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2eBAe0-1}}\nwprevnextdefs{NW4Bsmdy-PmwVg-3}{\relax}\nwenddeflinemarkup
#self.socket.send(ubjson.dumpb(args_out,no_float32=True))
self._send_(args_out)
\nwused{\\{NW4Bsmdy-2eBAe0-1}}\nwendcode{}\nwbegindocs{16}\nwdocspar

\subsection{The S classes}
\label{sec:s-classes}

The S classes, \emph{SGMT}, \emph{SAtmosphere} and \emph{SOpticalPath}, are providing the interface with CEO classes. 
They mirror the \emph{Level--2 Matlab S--functions} by implementing the same method \emph{Start}, \emph{InitializeConditions}, \emph{Terminate}, \emph{Update} and \emph{Outputs}.
Each method is triggered by the corresponding function in the Matlab S--function with the exception of the \emph{Update} method that is triggered by the \emph{Outputs} function of the S--function.

An abstract class, \emph{Sfunction}, implements the four S--function method:
\nwenddocs{}\nwbegincode{17}\sublabel{NW4Bsmdy-3Fygjc-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3Fygjc-1}}}\moddef{S-function~{\nwtagstyle{}\subpageref{NW4Bsmdy-3Fygjc-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwenddeflinemarkup
from abc import ABCMeta, abstractmethod

class Sfunction:
    __metaclass__ = ABCMeta
    @abstractmethod
    def Start(self):
        pass
    @abstractmethod
    def Terminate(self):
        pass
    @abstractmethod
    def Update(self):
        pass
    @abstractmethod
    def Outputs(self):
        pass
    @abstractmethod
    def InitializeConditions(self):
        pass
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{18}\nwdocspar

\subsubsection{The SGMT class}
\label{sec:sgmt-class}

The \emph{SGMT} class is the interface class between a CEO \emph{GMT\_MX} object and a \emph{GMT Mirror}  Simulink block.
\nwenddocs{}\nwbegincode{19}\sublabel{NW4Bsmdy-DzA6J-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-1}}}\moddef{SGMT~{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{\relax}{NW4Bsmdy-DzA6J-2}\nwenddeflinemarkup
class SGMT(Sfunction):

    def __init__(self, ops, satm, verbose=logging.INFO):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(verbose)
        self.logger.info('Instantiate')
        self.gmt  = ceo.GMT_MX()
        self.state0 = copy.deepcopy(self.gmt.state)

    def Terminate(self, args=None):
        self.logger.info('Terminate')
        self.gmt = ceo.GMT_MX()
        return "GMT deleted!"
\nwalsodefined{\\{NW4Bsmdy-DzA6J-2}\\{NW4Bsmdy-DzA6J-3}\\{NW4Bsmdy-DzA6J-4}\\{NW4Bsmdy-DzA6J-5}}\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{20}\nwdocspar

\paragraph{Start}

The message that triggers the call to the \emph{Start} method is
\nwenddocs{}\nwbegincode{21}\sublabel{NW4Bsmdy-H7a38-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-H7a38-1}}}\moddef{SGMT Start message~{\nwtagstyle{}\subpageref{NW4Bsmdy-H7a38-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\{
"class_id": "GMT",
"method_id": "Start",
"args": 
  \{
    "mirror": "M1"|"M2",
    "mirror_args": 
      \{
        "mirror_modes": u"bending modes"|u"zernike",
        "N_MODE": 162,
        "radial_order": ...
      \}
  \}
\}
\nwnotused{SGMT Start message}\nwendcode{}\nwbegindocs{22}\nwdocspar
\nwenddocs{}\nwbegincode{23}\sublabel{NW4Bsmdy-DzA6J-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-2}}}\moddef{SGMT~{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-DzA6J-1}{NW4Bsmdy-DzA6J-3}\nwenddeflinemarkup
    def Start(self,mirror=None,mirror_args=\{\}):
        self.logger.info('Start')
        if mirror_args:
            self.gmt[mirror] = getattr(ceo,"GMT_"+mirror)( **mirror_args )
            self.state0 = copy.deepcopy(self.gmt.state)
        return "GMT"
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{24}\nwdocspar

\paragraph{Update}

The message that triggers the call to the \emph{Update} method is
\nwenddocs{}\nwbegincode{25}\sublabel{NW4Bsmdy-18W6Vx-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-18W6Vx-1}}}\moddef{SOpticalPath Update message~{\nwtagstyle{}\subpageref{NW4Bsmdy-18W6Vx-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW4Bsmdy-18W6Vx-2}\nwenddeflinemarkup
\{
"class_id": "GMT",
"method_id": "Update",
"args": 
  \{
    "mirror": "M1"|"M2",
    "inputs":
      \{
        "Txyz": null,
        "Rxyz": null,
        "modes": null
      \}
  \}
\}
\nwalsodefined{\\{NW4Bsmdy-18W6Vx-2}}\nwnotused{SOpticalPath Update message}\nwendcode{}\nwbegindocs{26}\nwdocspar
\nwenddocs{}\nwbegincode{27}\sublabel{NW4Bsmdy-DzA6J-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-3}}}\moddef{SGMT~{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-DzA6J-2}{NW4Bsmdy-DzA6J-4}\nwenddeflinemarkup
    def Update(self, mirror=None, inputs=None):
        self.logger.debug("Updating %s", mirror)
        state = self.gmt.state
        for dof in inputs:
            if dof=='Rxy':
                data = np.zeros((7,3))
                data[:,:2] = np.asarray( inputs[dof], order='C', dtype=np.float64 )
                dof = 'Rxyz'
            elif dof=='Tz':
                data = np.zeros((7,3))
                data[:,2] = np.ravel(np.asarray( inputs[dof], order='C', dtype=np.float64 ))
                dof = 'Txyz'
            else:
                data = np.asarray( inputs[dof], order='C', dtype=np.float64 )
            #data = np.transpose( np.reshape( data , (-1,7) ) )
            self.logger.debug(" . DOF: %s=|%s|", dof, np.array_str(norm(data,axis=1)))
            state[mirror][dof][:] = self.state0[mirror][dof][:] + data
            """
            if key=="TxyzRxyz":
                state[mirror]['Txyz'][:] += data[:,:3].copy()
                state[mirror]['Rxyz'][:] += data[:,3:].copy()
            elif key=="Rxy":
                state[mirror]['Rxyz'][:,:2] += data.copy()
            elif key=="Tz":
                state[mirror]['Txyz'][:,2] += data.ravel().copy()
            elif key=="mode_coefs":
                state[mirror]['modes'][:] += data.copy()
            """
        self.logger.debug('GMT STATE: %s',state)
        self.gmt^=state
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{28}\nwdocspar
\paragraph{InitializeConditions}

\nwenddocs{}\nwbegincode{29}\sublabel{NW4Bsmdy-DzA6J-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-4}}}\moddef{SGMT~{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-DzA6J-3}{NW4Bsmdy-DzA6J-5}\nwenddeflinemarkup
    def Init(self, state=\{\}):
        for mirror in state:
            self.state0[mirror].update(state[mirror])
            self.logger.info("GMT state set to %s",self.state0)
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{30}\nwdocspar
\paragraph{Outputs}

\nwenddocs{}\nwbegincode{31}\sublabel{NW4Bsmdy-DzA6J-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-5}}}\moddef{SGMT~{\nwtagstyle{}\subpageref{NW4Bsmdy-DzA6J-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-DzA6J-4}{\relax}\nwenddeflinemarkup
    def Outputs(self, args=None):
        pass
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{32}\nwdocspar

\subsubsection{The SAtmosphere class}
\label{sec:satmosphere-class}

The \emph{SAtmosphere} class is the interface class between a CEO \emph{GmtAtmosphere} object and a \emph{Atmosphere} Simulink block.
\nwenddocs{}\nwbegincode{33}\sublabel{NW4Bsmdy-4UUQgn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4UUQgn-1}}}\moddef{SAtmosphere~{\nwtagstyle{}\subpageref{NW4Bsmdy-4UUQgn-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwenddeflinemarkup
class _Atmosphere_():
    def __init__(self,**kwargs):
        print(kwargs)
        self.__atm = ceo.GmtAtmosphere(**kwargs)
        self.N = kwargs['NXY_PUPIL']
        self.L = kwargs['L']
        self.delta = self.L/(self.N-1)
    def propagate(self,\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}):
        self.__atm.ray_tracing(\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},self.delta,self.N,self.delta,self.N,\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.timeStamp)
class SAtmosphere(Sfunction):

    def __init__(self, ops, verbose=logging.INFO):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(verbose)
        self.atm = None

    def Start(self, **kwargs):
        print("\\n@(SAtmosphere:Start)>")
        #self.atm = _Atmosphere_( **kwargs )
        self.atm = ceo.GmtAtmosphere(**kwargs)
        return "ATM"

    def Terminate(self, args=None):
        self.logger.info("\nwlinkedidentc{Atmosphere}{NW4Bsmdy-439t7Z-5} deleted")
        self.atm = None
        return "\nwlinkedidentc{Atmosphere}{NW4Bsmdy-439t7Z-5} deleted!"

    def InitializeConditions(self, args=None):
        pass

    def Outputs(self, args=None):
        pass

    def Update(self, args=None):
        pass
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwidentuses{\\{{\nwixident{Atmosphere}}{Atmosphere}}\\{{\nwixident{src}}{src}}}\nwindexuse{\nwixident{Atmosphere}}{Atmosphere}{NW4Bsmdy-4UUQgn-1}\nwindexuse{\nwixident{src}}{src}{NW4Bsmdy-4UUQgn-1}\nwendcode{}\nwbegindocs{34}\nwdocspar

\subsubsection{The SOpticalPath class}
\label{sec:sopticalpath-class}

The \emph{SOpticalClass} gathers a source object \emph{src}, the GMT model object 
\emph{gmt}, an atmosphere object \emph{atm}, a sensor object \emph{sensor} and a calibration source \emph{calib\_src}.
\nwenddocs{}\nwbegincode{35}\sublabel{NW4Bsmdy-rFcsf-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\moddef{SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{\relax}{NW4Bsmdy-rFcsf-2}\nwenddeflinemarkup
class SOpticalPath(Sfunction):

    def __init__(self, \nwlinkedidentc{idx}{NW4Bsmdy-rFcsf-1}, gmt, atm, verbose=logging.INFO):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(verbose)
        self.logger.info('Instantiate')
        self.\nwlinkedidentc{idx}{NW4Bsmdy-rFcsf-1} = \nwlinkedidentc{idx}{NW4Bsmdy-rFcsf-1}
        self.gmt = gmt
        self.atm = atm
        self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1} = None
\nwindexdefn{\nwixident{idx}}{idx}{NW4Bsmdy-rFcsf-1}\nwindexdefn{\nwixident{sensor}}{sensor}{NW4Bsmdy-rFcsf-1}\eatline
\nwalsodefined{\\{NW4Bsmdy-rFcsf-2}\\{NW4Bsmdy-rFcsf-3}\\{NW4Bsmdy-rFcsf-4}\\{NW4Bsmdy-rFcsf-5}\\{NW4Bsmdy-rFcsf-6}\\{NW4Bsmdy-rFcsf-7}}\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwidentdefs{\\{{\nwixident{idx}}{idx}}\\{{\nwixident{sensor}}{sensor}}}\nwendcode{}\nwbegindocs{36}\paragraph{Start}

The message that triggers the call to the \emph{Start} method is
\nwenddocs{}\nwbegincode{37}\sublabel{NW4Bsmdy-qPv2I-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-qPv2I-1}}}\moddef{SOpticalPath Start message~{\nwtagstyle{}\subpageref{NW4Bsmdy-qPv2I-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\{
"class_id": "OP",
"method_id": "Start",
"args": 
  \{
    "source_args": \{ ... \} ,
    "sensor_class": null|"Imaging"|"ShackHartmann",
    "sensor_args": null|\{ ... \},
    "calibration_source": null|\{ ... \},...
    "miscellaneous_args": null|\{...\}
  \}
\}
\nwnotused{SOpticalPath Start message}\nwendcode{}\nwbegindocs{38}\nwdocspar
\nwenddocs{}\nwbegincode{39}\sublabel{NW4Bsmdy-rFcsf-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-2}}}\moddef{SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-rFcsf-1}{NW4Bsmdy-rFcsf-3}\nwenddeflinemarkup
    def Start(self,source_args=None, source_attributes=\{\},
              sensor_class=None, sensor_args=None,
              calibration_source_args=None, calibrate_args=None):
        self.pssn_data = None
        #self.\nwlinkedidentc{propagateThroughAtm}{NW4Bsmdy-rFcsf-2} = miscellaneous_args['propagate_through_atmosphere']
        self.logger.info('Instantiating source')
        self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2} = ceo.Source( **source_args )
        for key in source_attributes:
            attr = source_attributes[key]
            if isinstance(attr,dict):
                for kkey in attr:
                    setattr(getattr(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},key),kkey,attr[kkey])
            else:
                setattr(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},key,attr)
        self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.reset()
        self.gmt.reset()
        self.gmt.propagate(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2})
        self.sensor_class = sensor_class
        
        if not (sensor_class is None or sensor_class=='None'):

            self.logger.info('Instantiating sensor')
            self.logger.debug(sensor_class)
            self.logger.debug(sensor_args)
            self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1} = getattr(ceo,sensor_class)( **sensor_args )
            if calibration_source_args is None:
                self.calib_src = self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}
            else:
                self.calib_src = ceo.Source( **calibration_source_args )
        
            self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.reset()
            if calibrate_args is not None:
                self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.calibrate(self.calib_src, **calibrate_args)
            #print "intensity_threshold: %f"%sensor_args['intensityThreshold']

            self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.reset()
            self.comm_matrix = \{\}

        self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}>>tuple(filter(None,(self.atm,self.gmt,self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1})))

        return "OP"+str(self.\nwlinkedidentc{idx}{NW4Bsmdy-rFcsf-1})
\nwindexdefn{\nwixident{src}}{src}{NW4Bsmdy-rFcsf-2}\nwindexdefn{\nwixident{propagateThroughAtm}}{propagateThroughAtm}{NW4Bsmdy-rFcsf-2}\nwindexdefn{\nwixident{exposure{\_}start}}{exposure:unstart}{NW4Bsmdy-rFcsf-2}\nwindexdefn{\nwixident{exposure{\_}time}}{exposure:untime}{NW4Bsmdy-rFcsf-2}\eatline
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwidentdefs{\\{{\nwixident{exposure{\_}start}}{exposure:unstart}}\\{{\nwixident{exposure{\_}time}}{exposure:untime}}\\{{\nwixident{propagateThroughAtm}}{propagateThroughAtm}}\\{{\nwixident{src}}{src}}}\nwidentuses{\\{{\nwixident{idx}}{idx}}\\{{\nwixident{sensor}}{sensor}}}\nwindexuse{\nwixident{idx}}{idx}{NW4Bsmdy-rFcsf-2}\nwindexuse{\nwixident{sensor}}{sensor}{NW4Bsmdy-rFcsf-2}\nwendcode{}\nwbegindocs{40}\nwdocspar
\paragraph{Terminate}

The message that triggers the call to the \emph{Terminate} method is
\nwenddocs{}\nwbegincode{41}\sublabel{NW4Bsmdy-8xvhs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-8xvhs-1}}}\moddef{SOpticalPath Terminate message~{\nwtagstyle{}\subpageref{NW4Bsmdy-8xvhs-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\{
"class_id": "OP",
"method_id": "Terminate",
"args": 
  \{
    "args": null
  \}
\}
\nwnotused{SOpticalPath Terminate message}\nwendcode{}\nwbegindocs{42}\nwdocspar
\nwenddocs{}\nwbegincode{43}\sublabel{NW4Bsmdy-rFcsf-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-3}}}\moddef{SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-rFcsf-2}{NW4Bsmdy-rFcsf-4}\nwenddeflinemarkup
    def Terminate(self, args=None):
        self.logger.info("OpticalPath deleted")
        return "OpticalPath deleted!"
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{44}\nwdocspar
\paragraph{Update}

The message that triggers the call to the \emph{Update} method is
\nwenddocs{}\nwbegincode{45}\sublabel{NW4Bsmdy-18W6Vx-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-18W6Vx-2}}}\moddef{SOpticalPath Update message~{\nwtagstyle{}\subpageref{NW4Bsmdy-18W6Vx-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-18W6Vx-1}{\relax}\nwenddeflinemarkup
\{
"class_id": "OP",
"method_id": "Update",
"args": 
  \{
    "inputs": null
  \}
\}
\nwendcode{}\nwbegindocs{46}\nwdocspar
\nwenddocs{}\nwbegincode{47}\sublabel{NW4Bsmdy-rFcsf-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-4}}}\moddef{SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-rFcsf-3}{NW4Bsmdy-rFcsf-5}\nwenddeflinemarkup
    def Update(self, inputs=None):
        self.logger.debug('src time stamp: %f',self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.timeStamp)
        +self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}
        #self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.reset()
        #self.gmt.propagate(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2})
        #self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.propagate(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2})
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwidentuses{\\{{\nwixident{sensor}}{sensor}}\\{{\nwixident{src}}{src}}}\nwindexuse{\nwixident{sensor}}{sensor}{NW4Bsmdy-rFcsf-4}\nwindexuse{\nwixident{src}}{src}{NW4Bsmdy-rFcsf-4}\nwendcode{}\nwbegindocs{48}\nwdocspar

\paragraph{Outputs}

The message that triggers the call to the \emph{Outputs} method is
\nwenddocs{}\nwbegincode{49}\sublabel{NW4Bsmdy-34CYe8-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-34CYe8-1}}}\moddef{SOpticalPath Outputs message~{\nwtagstyle{}\subpageref{NW4Bsmdy-34CYe8-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\{
"class_id": "OP",
"method_id": "Outputs",
"args": 
  \{
      "outputs": ["wfe_rms"|"segment_wfe_rms"|"piston"|"segment_piston"|"ee80"]
  \}
\}
\nwnotused{SOpticalPath Outputs message}\nwendcode{}\nwbegindocs{50}\nwdocspar
\nwenddocs{}\nwbegincode{51}\sublabel{NW4Bsmdy-rFcsf-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-5}}}\moddef{SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-rFcsf-4}{NW4Bsmdy-rFcsf-6}\nwenddeflinemarkup
    def Outputs(self, outputs=None):
        if self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1} is None:
            doutputs = OrderedDict()
            for element in outputs:
                doutputs[element] = self[element]
        else:
            #+self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}
            self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.process()
            doutputs = OrderedDict()
            for element in outputs:
                doutputs[element] = self[element]
            self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.reset()
        return doutputs
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwidentuses{\\{{\nwixident{sensor}}{sensor}}}\nwindexuse{\nwixident{sensor}}{sensor}{NW4Bsmdy-rFcsf-5}\nwendcode{}\nwbegindocs{52}\nwdocspar
and the dictionnary implementation is
\nwenddocs{}\nwbegincode{53}\sublabel{NW4Bsmdy-rFcsf-6}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-6}}}\moddef{SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-rFcsf-5}{NW4Bsmdy-rFcsf-7}\nwenddeflinemarkup
    def __getitem__(self,key):
        if key=="wfe_rms":
            return self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.wavefront.rms(units_exponent=-6).tolist()
        elif key=="segment_wfe_rms":
            return self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.phaseRms(where="segments",
                                     units_exponent=-6).tolist()
        elif key=="piston":
            return self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.piston(where="pupil",
                                   units_exponent=-6).tolist()
        elif key=="segment_piston":
            return self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.piston(where="segments",
                                   units_exponent=-6).tolist()
        elif key=="tiptilt":
            buf = self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.wavefront.gradientAverage(1,self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.rays.L)
            buf *= ceo.constants.RAD2ARCSEC
            return buf.tolist()
        elif key=="segment_tiptilt":
            buf = self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.segmentsWavefrontGradient().T
            buf *= ceo.constants.RAD2ARCSEC
            return buf.tolist()
        elif key=="ee80":
            #print "EE80=%.3f or %.3f"%(self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.ee80(from_ghost=False),self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.ee80(from_ghost=True))
            return self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.ee80(from_ghost=False).tolist()
        elif key=="PSSn":
            if self.pssn_data is None:
                pssn , self.pssn_data = self.gmt.PSSn(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},save=True)
            else:
                pssn = self.gmt.PSSn(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},**self.pssn_data)
            return pssn
        elif hasattr(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},key):
            return getattr(self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},key)
        elif hasattr(self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1},key):
            return getattr(self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1},key)
        else:
            c = self.comm_matrix[key].dot( self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.Data ).ravel()
            return c.tolist()
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwidentuses{\\{{\nwixident{sensor}}{sensor}}\\{{\nwixident{src}}{src}}}\nwindexuse{\nwixident{sensor}}{sensor}{NW4Bsmdy-rFcsf-6}\nwindexuse{\nwixident{src}}{src}{NW4Bsmdy-rFcsf-6}\nwendcode{}\nwbegindocs{54}\nwdocspar
\paragraph{InitializeConditions}

The message that triggers a call to the \emph{InitializeConditions} method is

\nwenddocs{}\nwbegincode{55}\sublabel{NW4Bsmdy-2zXOJO-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2zXOJO-1}}}\moddef{SOpticalPath InitializeConditions message~{\nwtagstyle{}\subpageref{NW4Bsmdy-2zXOJO-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW4Bsmdy-2zXOJO-2}\nwenddeflinemarkup
\{
"class_id": "OP",
"method_id": "InitializeConditions",
"args": 
  \{
      "calibrations":
      \{
          "M2_TT":
          \{
              "method_id": "calibrate",
              "args":
              \{
                  "mirror": "M2",
                  "mode": "segment tip-tilt",
                  "stroke": 1e-6
              \}
          \},
      \},
      "pseudo_inverse":
      \{
          "nThreshold": null
      \},
      "filename": null
  \}       
\}
\nwalsodefined{\\{NW4Bsmdy-2zXOJO-2}\\{NW4Bsmdy-2zXOJO-3}}\nwnotused{SOpticalPath InitializeConditions message}\nwendcode{}\nwbegincode{56}\sublabel{NW4Bsmdy-2zXOJO-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2zXOJO-2}}}\moddef{SOpticalPath InitializeConditions message~{\nwtagstyle{}\subpageref{NW4Bsmdy-2zXOJO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-2zXOJO-1}{NW4Bsmdy-2zXOJO-3}\nwenddeflinemarkup
\{
"class_id": "OP",
"method_id": "InitializeConditions",
"args": 
  \{
      "calibrations":
      \{
          "M12_Rxyz": [
              \{
                  "method_id": "calibrate",
                  "args":
                  \{
                      "mirror": "M1",
                      "mode": "Rxyz",
                      "stroke": 1e-6
                  \}
              \},
              \{
                  "method_id": "calibrate",
                  "args":
                  \{
                      "mirror": "M2",
                      "mode": "Rxyz",
                      "stroke": 1e-6
                  \}
              \}]
      \},
      "pseudo-inverse":
      \{
          "nThreshold": [0],
          "concatenate": true
      \},
      "filename": null
  \}
\}
\nwendcode{}\nwbegincode{57}\sublabel{NW4Bsmdy-2zXOJO-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2zXOJO-3}}}\moddef{SOpticalPath InitializeConditions message~{\nwtagstyle{}\subpageref{NW4Bsmdy-2zXOJO-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-2zXOJO-2}{\relax}\nwenddeflinemarkup
\{
"class_id": "OP",
"method_id": "InitializeConditions",
"args": 
  \{
      "calibrations":
      \{         
          "AGWS":               
          \{
              "method_id": "AGWS_calibrate",
              "args":
              \{
                  "decoupled": true,
                  "stroke": [1e-6,1e-6,1e-6,1e-6,1e-6],
                  "fluxThreshold": 0.5
              \}
          \}
      \},
      "pseudo-inverse":
      \{
          "nThreshold": [2,2,2,2,2,2,0],
          "insertZeros": [null,null,null,null,null,null,[2,4,6]]
      \},
      "filename": null
  \}
\}
\nwendcode{}\nwbegindocs{58}\nwdocspar
\nwenddocs{}\nwbegincode{59}\sublabel{NW4Bsmdy-rFcsf-7}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-7}}}\moddef{SOpticalPath~{\nwtagstyle{}\subpageref{NW4Bsmdy-rFcsf-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwprevnextdefs{NW4Bsmdy-rFcsf-6}{\relax}\nwenddeflinemarkup
    def Init(self, calibrations=None, filename=None,
         pseudo_inverse=\{\}):
        self.logger.info('INIT')
        if calibrations is not None:
            if filename is not None:
                filepath = os.path.join(SIMCEOPATH,"calibration_dbs",filename)
                db = shelve.open(filepath)
                
                if os.path.isfile(filepath+".dir"):
                    self.logger.info("Loading command matrix from existing database %s!",filename)
                    for key in db:
                        C = db[key]
                        #C.nThreshold = [SVD_truncation[k]]
                        self.comm_matrix[key] = C
                        db[key] = C
                    db.close()
                    return
                
            with Timer():
                for key in calibrations: # Through calibrations
                    self.logger.info('Calibrating: %s',key)
                    calibs = calibrations[key]
                    #Gif not isinstance(calibs,list):
                    #    calibs = [calibs]
                    #GD = []
                    #for c in calibs: # Through calib
                    self.gmt.reset()
                    self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.reset()
                    self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.reset()
                    if calibs["method_id"]=="AGWS_calibrate":
                        C = getattr( self.gmt, calibs["method_id"] )( \\
                                        self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}, 
                                        self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},
                                        **calibs["args"],
                                        calibrationVaultKwargs=pseudo_inverse)
                    else:
                        D = getattr( self.gmt, calibs["method_id"] )( \\
                                        self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}, 
                                        self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2},
                                        **calibs["args"])
                        C = ceo.CalibrationVault([D],**pseudo_inverse)
                    self.gmt.reset()
                    self.\nwlinkedidentc{src}{NW4Bsmdy-rFcsf-2}.reset()
                    self.\nwlinkedidentc{sensor}{NW4Bsmdy-rFcsf-1}.reset()
                    self.comm_matrix[key] = C


            if filename is not None:
                self.logger.info("Saving command matrix to database %s!",filename)
                db[str(key)] = C
                db.close()
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwidentuses{\\{{\nwixident{sensor}}{sensor}}\\{{\nwixident{src}}{src}}}\nwindexuse{\nwixident{sensor}}{sensor}{NW4Bsmdy-rFcsf-7}\nwindexuse{\nwixident{src}}{src}{NW4Bsmdy-rFcsf-7}\nwendcode{}\nwbegindocs{60}\nwdocspar

\subsection{The CalibrationMatrix class}
\label{sec:calibr-class}

The \emph{CalibrationMatrix} class is a container for several matrices:
\begin{itemize}
\item the poke matrix $D$,
\item the eigen modes $U,V$ and eigen values $S$ of the singular value decomposition of $D=USV^T$
\item the truncated inverse $M$ of $D$, $M=V\Lambda U^T$ where
  \begin{eqnarray}
    \label{eq:2}
      \Lambda_i &=& 1/S_i,\quad \forall i<n \nonumber\\
      \Lambda_i &=& 0,\quad \forall i\geq n \nonumber    
  \end{eqnarray}
\end{itemize}

\nwenddocs{}\nwbegincode{61}\sublabel{NW4Bsmdy-3jZIZN-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3jZIZN-1}}}\moddef{CalibrationMatrix~{\nwtagstyle{}\subpageref{NW4Bsmdy-3jZIZN-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-3TXSTG-1}}\nwenddeflinemarkup
class CalibrationMatrix(object):

    def __init__(self, D, n, 
                 decoupled=True, flux_filter2=None,
                 n_mode = None):
        print("@(CalibrationMatrix)> Computing the SVD and the pseudo-inverse...")
        self._n = n
        self.decoupled = decoupled
        if self.decoupled:
            self.nSeg = 7
            self.D = D
            D_s = [ np.concatenate([D[0][:,k*3:k*3+3],
                                    D[1][:,k*3:k*3+3],
                                    D[2][:,k*3:k*3+3],
                                    D[3][:,k*3:k*3+3],
                                    D[4][:,k*n_mode:k*n_mode+n_mode]],axis=1) for k in range(self.nSeg)]
            for k in range(7):
                D_s[k][np.isnan(D_s[k])] = 0
            lenslet_array_shape = flux_filter2.shape

            ### Identification process
            # The non-zeros entries of the calibration matrix are identified by filtering out all the values 
            # which are a 1000 less than the maximum of the absolute values of the matrix and 
            # collapsing (summing) the matrix along the mirror modes axis.
            Qxy = [ np.reshape( np.sum(np.abs(D_s[k])>1e-2*np.max(np.abs(D_s[k])),axis=1)!=0 ,flux_filter2.shape ) for k in range(self.nSeg) ]
            # The lenslet flux filter is applied to the lenslet segment filter:
            Q = [ np.logical_and(X,flux_filter2) for X in Qxy ]
            # A filter made of the lenslet used more than once is created:
            Q3 = np.dstack(Q).reshape(flux_filter2.shape + (self.nSeg,))
            Q3clps = np.sum(Q3,axis=2)
            Q3clps = Q3clps>1
            # The oposite filter is applied to the lenslet segment filter leading to 7 valid lenslet filters, 
            # one filter per segment and no lenslet used twice:
            self.VLs = [ np.logical_and(X,~Q3clps) for X in Q] 

            # Each calibration matrix is reduced to the valid lenslet:
            D_sr = [ D_s[k][self.VLs[k].ravel(),:] for k in range(self.nSeg) ]
            print([ D_sr[k].shape for k in range(self.nSeg)])
            # Computing the SVD for each segment:
            self.UsVT = [LA.svd(X,full_matrices=False) for X in D_sr]

            # and the command matrix of each segment
            self.M = [ self.__recon__(k) for k in range(self.nSeg) ]
        else:
            self.D = np.concatenate( D, axis=1 )
            with Timer():
                self.U,self.s,self.V = LA.svd(self.D,full_matrices=False)
                self.V = self.V.T
                iS = 1./self.s
                if self._n>0:
                    iS[-self._n:] = 0
                self.M = np.dot(self.V,np.dot(np.diag(iS),self.U.T))
            
    def __recon__(self,k):
        iS = 1./self.UsVT[k][1]
        if self._n>0:
            iS[-self._n:] = 0
        return np.dot(self.UsVT[k][2].T,np.dot(np.diag(iS),self.UsVT[k][0].T))
            
    @property
    def nThreshold(self):
        "# of discarded eigen values"
        return self._n
    @nThreshold.setter
    def nThreshold(self, value):
        print("@(CalibrationMatrix)> Updating the pseudo-inverse...")
        self._n = value
        if self.decoupled:
            self.M = [ self.__recon__(k) for k in range(self.nSeg) ]
        else:
            iS = 1./self.s
            if self._n>0:
                iS[-self._n:] = 0
            self.M = np.dot(self.V,np.dot(np.diag(iS),self.U.T))

    def dot( self, s ):
        if self.decoupled:
            return np.concatenate([ np.dot(self.M[k],s[self.VLs[k].ravel()]) for k in range(self.nSeg) ])
        else:
            return np.dot(self.M,s)
\nwused{\\{NW4Bsmdy-3TXSTG-1}}\nwendcode{}\nwbegindocs{62}\nwdocspar
\subsection{The Sensor abstract class}
\label{sec:sens-abstr-class}

\nwenddocs{}\nwbegincode{63}\sublabel{NW4Bsmdy-1v0g0h-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1v0g0h-1}}}\moddef{Sensor abstract class~{\nwtagstyle{}\subpageref{NW4Bsmdy-1v0g0h-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
class Sensor:
    __metaclass__ = ABCMeta
    @abstractmethod
    def calibrate(self):
        pass
    @abstractmethod
    def reset(self):
        pass
    @abstractmethod
    def analyze(self):
        pass
    @abstractmethod
    def propagate(self):
        pass
    @abstractmethod
    def process(self):
        pass
\nwnotused{Sensor abstract class}\nwendcode{}\nwbegindocs{64}\nwdocspar


\section{DOS}
\label{sec:DOS}

{\Tt{}dos\nwendquote} is the interface to the dynamic optical simulation.
A {\Tt{}dos\nwendquote} simulation is defined with a parameter file {\Tt{}dos.yaml\nwendquote}.
{\Tt{}dos.yaml\nwendquote} is divided into several sections.
\nwenddocs{}\nwbegincode{65}\sublabel{NW4Bsmdy-438U8x-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-438U8x-1}}}\moddef{dos.yaml~{\nwtagstyle{}\subpageref{NW4Bsmdy-438U8x-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}dos simulation section~{\nwtagstyle{}\subpageref{NW4Bsmdy-2KRSGK-1}}\RA{}
\LA{}dos drivers section~{\nwtagstyle{}\subpageref{NW4Bsmdy-4eUt8y-1}}\RA{}
\nwnotused{dos.yaml}\nwendcode{}\nwbegincode{66}\sublabel{NW4Bsmdy-zxoFq-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-zxoFq-1}}}\moddef{init.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-zxoFq-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
from . import mpc_driver
from . import control
from . import driver
from .dos import DOS, Logs
\nwnotused{init.py}\nwendcode{}\nwbegindocs{67}\nwdocspar
\subsection{Simulation}
\label{sec:simulation}


The first section is {\Tt{}simulation\nwendquote} where the simulation sampling frequency and
duration is given as well as the address of the SIMCEO server.
\nwenddocs{}\nwbegincode{68}\sublabel{NW4Bsmdy-2KRSGK-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2KRSGK-1}}}\moddef{dos simulation section~{\nwtagstyle{}\subpageref{NW4Bsmdy-2KRSGK-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-438U8x-1}}\nwenddeflinemarkup
simulation:
  sampling frequency: # [Hertz]
  duration: # [seconds]
  server:
    IP: # 127.0.0.1
\nwused{\\{NW4Bsmdy-438U8x-1}}\nwendcode{}\nwbegindocs{69}\nwdocspar

The {\Tt{}DOS\nwendquote} class acts as the simulation conductor.
It is initialized with the path to the directory where the configuration and
parameter files reside.
\nwenddocs{}\nwbegincode{70}\sublabel{NW4Bsmdy-4SxboR-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-1}}}\moddef{dos imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwprevnextdefs{\relax}{NW4Bsmdy-4SxboR-2}\nwenddeflinemarkup
import os
import time
import logging
import threading
import numpy as np
from ruamel.yaml import YAML
yaml=YAML(typ='safe')
from .driver import \nwlinkedidentc{Server}{NWD4Bsmdy-1}, \nwlinkedidentc{Client}{NW4Bsmdy-439t7Z-4}, \nwlinkedidentc{Atmosphere}{NW4Bsmdy-439t7Z-5}
\nwalsodefined{\\{NW4Bsmdy-4SxboR-2}\\{NW4Bsmdy-4SxboR-3}\\{NW4Bsmdy-4SxboR-4}}\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwidentuses{\\{{\nwixident{Atmosphere}}{Atmosphere}}\\{{\nwixident{Client}}{Client}}\\{{\nwixident{Server}}{Server}}}\nwindexuse{\nwixident{Atmosphere}}{Atmosphere}{NW4Bsmdy-4SxboR-1}\nwindexuse{\nwixident{Client}}{Client}{NW4Bsmdy-4SxboR-1}\nwindexuse{\nwixident{Server}}{Server}{NW4Bsmdy-4SxboR-1}\nwendcode{}\nwbegincode{71}\sublabel{NW4Bsmdy-42xnBU-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-1}}}\moddef{dos.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW4Bsmdy-42xnBU-2}\nwenddeflinemarkup
\LA{}dos imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-1}}\RA{}

logging.basicConfig()

class Timer(object):
    def __init__(self, name=None):
        self.name = name

    def __enter__(self):
        self.tstart = time.time()

    def __exit__(self, type, value, traceback):
        if self.name:
            print('[%s]' % self.name)
        print('Elapsed time: %s' % (time.time() - self.tstart))

class DOS(threading.Thread):
    def __init__(self,path_to_config_dir,verbose=logging.INFO,
                 show_timing=0):

        threading.Thread.__init__(self)

        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.setLevel(verbose)

        self.DOS_REPO = path_to_config_dir
        cfg_file = os.path.join(path_to_config_dir,'dos.yaml')
        self.logger.info('Reading config from %s',cfg_file)
        with open(cfg_file) as f:
            self.cfg = yaml.load(f)

        self.agent = None
        if show_timing in [0,2]:
            self.agent = broker(self.cfg['simulation']['server']['IP'])

        self.N_SAMPLE = int(self.cfg['simulation']['sampling frequency']*
                            self.cfg['simulation']['duration'])
        self.__k_step = 0
        self.pushed = False
        self.initialized = False
        \LA{}check parameter file existence~{\nwtagstyle{}\subpageref{NW4Bsmdy-1qDwLh-1}}\RA{}
        \LA{}linking the drivers IO~{\nwtagstyle{}\subpageref{NW4Bsmdy-1zQ8wi-1}}\RA{}
        \LA{}device to driver association~{\nwtagstyle{}\subpageref{NW4Bsmdy-4A0PIB-1}}\RA{}
        \LA{}starting the drivers~{\nwtagstyle{}\subpageref{NW4Bsmdy-p2ZYp-1}}\RA{}
        \LA{}initializing the drivers~{\nwtagstyle{}\subpageref{NW4Bsmdy-1lxN2y-1}}\RA{}
        \LA{}running the loop~{\nwtagstyle{}\subpageref{NW4Bsmdy-3sOZsM-1}}\RA{}
        \LA{}terminating the drivers~{\nwtagstyle{}\subpageref{NW4Bsmdy-1F7pYs-1}}\RA{}
        self.logger.info('Simulation setup for a duration of \{0\}s @ \{1\}Hz (\{2\} steps)!'.format(
            self.cfg['simulation']['duration'],
            self.cfg['simulation']['sampling frequency'],
            self.N_SAMPLE))

        if show_timing>0:
            self.diagram(filename=os.path.join(self.DOS_REPO,'timing'),format='png')

    \LA{}starting the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-1ebFFG-1}}\RA{}

    \LA{}initializing the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-2Jt2yo-1}}\RA{}

    \LA{}stepping through~{\nwtagstyle{}\subpageref{NW4Bsmdy-4CTiGt-1}}\RA{}

    \LA{}running the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-3jYsn6-1}}\RA{}

    \LA{}terminating the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-3UROtz-1}}\RA{}

    \LA{}timing diagram~{\nwtagstyle{}\subpageref{NW4Bsmdy-xTFQY-1}}\RA{}

    @property
    def pctComplete(self):
        return round(100*self.__k_step/(self.N_SAMPLE-1))
\nwalsodefined{\\{NW4Bsmdy-42xnBU-2}\\{NW4Bsmdy-42xnBU-3}\\{NW4Bsmdy-42xnBU-4}}\nwnotused{dos.py}\nwendcode{}\nwbegindocs{72}\nwdocspar

\subsubsection{Driver instanciation}
\label{sec:driver-instanciation}

Each device must have a corresponding parameter file in the same directory than
the configuration file.
\nwenddocs{}\nwbegincode{73}\sublabel{NW4Bsmdy-1qDwLh-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1qDwLh-1}}}\moddef{check parameter file existence~{\nwtagstyle{}\subpageref{NW4Bsmdy-1qDwLh-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
tau = 1/self.cfg['simulation']['sampling frequency']
self.logs = Logs(tau,logs_repo=self.DOS_REPO)
self.drivers = \{\}
for d,v in self.cfg['drivers'].items():
    prm_file = os.path.join(path_to_config_dir,d)
    if os.path.isfile(prm_file+'.yaml') or os.path.isfile(prm_file+'.pickle'):
        self.logger.info('New driver: %s',d)
        if 'server' in v and v['server'] is False:
            self.drivers[d] = \nwlinkedidentc{Client}{NW4Bsmdy-439t7Z-4}(tau,d,
                                            self.logs,
                                            verbose=verbose,**v)
        elif d=='atmosphere':
            self.drivers[d] = \nwlinkedidentc{Atmosphere}{NW4Bsmdy-439t7Z-5}(tau,d,self.agent,
                                                verbose=verbose)
        else:
            self.drivers[d] = \nwlinkedidentc{Server}{NWD4Bsmdy-1}(tau,d,
                                            self.logs,
                                            self.agent,
                                            verbose=verbose,**v)
    else:
        self.logger.warning('%s is missing!',prm_file)
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwidentuses{\\{{\nwixident{Atmosphere}}{Atmosphere}}\\{{\nwixident{Client}}{Client}}\\{{\nwixident{Server}}{Server}}}\nwindexuse{\nwixident{Atmosphere}}{Atmosphere}{NW4Bsmdy-1qDwLh-1}\nwindexuse{\nwixident{Client}}{Client}{NW4Bsmdy-1qDwLh-1}\nwindexuse{\nwixident{Server}}{Server}{NW4Bsmdy-1qDwLh-1}\nwendcode{}\nwbegindocs{74}\nwdocspar
% For an optical sensor, the {\Tt{}device\ name.yaml\nwendquote} file has 3 sections: source,
% sensor and calibrations.
% Each section list the arguments of CEO methods.
% <device name.yaml>=
% source:
%   photometric_band: R+I
%   zenith:
%     value: 8
%     units: arcmin
%   azimuth:
%     value: 66
%     units: degree
%   magnitude: 0
%   rays_box_size: 25.5000
%   rays_box_sampling: 769
%   rays_origin: [0,0,25]
% sensor:
%   class: GeometricShackHartmann
%   args:
%     N_SIDE_LENSLET: 20
%   calibrate args: null
% calibrations:
%   M2TT:
%     method_id: calibrate
%     args:
%       mirror: M2
%       mode: segment tip-tilt
%       stroke: 1e-6
% @

\subsubsection{IO linking}
\label{sec:io-linking}

Once each driver is instantiated, their inputs and outputs are tied
\nwenddocs{}\nwbegincode{75}\sublabel{NW4Bsmdy-1zQ8wi-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1zQ8wi-1}}}\moddef{linking the drivers IO~{\nwtagstyle{}\subpageref{NW4Bsmdy-1zQ8wi-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
for k_d in self.drivers:
    d = self.drivers[k_d]
    for k_i in d.inputs:
        d.inputs[k_i].\nwlinkedidentc{tie}{NW4Bsmdy-47UBg5-1}(self.drivers)
    for k_o in d.outputs:
        d.outputs[k_o].\nwlinkedidentc{tie}{NW4Bsmdy-47UBg5-1}(self.drivers)
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwidentuses{\\{{\nwixident{tie}}{tie}}}\nwindexuse{\nwixident{tie}}{tie}{NW4Bsmdy-1zQ8wi-1}\nwendcode{}\nwbegindocs{76}\nwdocspar
The {\Tt{}\nwlinkedidentq{Input}{NW4Bsmdy-2F5kqp-1}\nwendquote} and {\Tt{}\nwlinkedidentq{Output}{NW4Bsmdy-2o1CzV-1}\nwendquote} {\Tt{}\nwlinkedidentq{tie}{NW4Bsmdy-47UBg5-1}\nwendquote} methods set the {\Tt{}data\nwendquote} pointer when a {\Tt{}lien\nwendquote} to another {\Tt{}\nwlinkedidentq{Driver}{NW4Bsmdy-439t7Z-2}\nwendquote} exists:
\nwenddocs{}\nwbegincode{77}\sublabel{NW4Bsmdy-2BoyHb-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2BoyHb-1}}}\moddef{IO linking~{\nwtagstyle{}\subpageref{NW4Bsmdy-2BoyHb-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-Lc6U0-1}\\{NW4Bsmdy-47UBg5-1}}\nwenddeflinemarkup
def \nwlinkedidentc{tie}{NW4Bsmdy-47UBg5-1}(self,drivers):
    if self.lien is not None:
        d,io = self.lien
        self.logger.info('Linked to %s from %s',io,d)
\nwused{\\{NW4Bsmdy-Lc6U0-1}\\{NW4Bsmdy-47UBg5-1}}\nwidentuses{\\{{\nwixident{tie}}{tie}}}\nwindexuse{\nwixident{tie}}{tie}{NW4Bsmdy-2BoyHb-1}\nwendcode{}\nwbegincode{78}\sublabel{NW4Bsmdy-Lc6U0-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-Lc6U0-1}}}\moddef{input linking~{\nwtagstyle{}\subpageref{NW4Bsmdy-Lc6U0-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2F5kqp-1}}\nwenddeflinemarkup
\LA{}IO linking~{\nwtagstyle{}\subpageref{NW4Bsmdy-2BoyHb-1}}\RA{}
        self.data = drivers[d].outputs[io].data
        self.size = self.data.shape
\nwused{\\{NW4Bsmdy-2F5kqp-1}}\nwendcode{}\nwbegincode{79}\sublabel{NW4Bsmdy-47UBg5-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-47UBg5-1}}}\moddef{output linking~{\nwtagstyle{}\subpageref{NW4Bsmdy-47UBg5-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-2o1CzV-1}}\nwenddeflinemarkup
\LA{}IO linking~{\nwtagstyle{}\subpageref{NW4Bsmdy-2BoyHb-1}}\RA{}
        self.data = drivers[d].inputs[io].data
        self.size = self.data.shape
\nwindexdefn{\nwixident{tie}}{tie}{NW4Bsmdy-47UBg5-1}\eatline
\nwused{\\{NW4Bsmdy-2o1CzV-1}}\nwidentdefs{\\{{\nwixident{tie}}{tie}}}\nwendcode{}\nwbegindocs{80}\nwdocspar
\subsubsection{Device association}
\label{sec:dev-assoc}

The device parameters are loaded from the device parameter file and the device
is associated to the driver
\nwenddocs{}\nwbegincode{81}\sublabel{NW4Bsmdy-4A0PIB-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4A0PIB-1}}}\moddef{device to driver association~{\nwtagstyle{}\subpageref{NW4Bsmdy-4A0PIB-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
for k_d in self.drivers:
    d = self.drivers[k_d]
    device = os.path.join(path_to_config_dir,k_d)
    try:
        with open(device+'.yaml') as f:
            prm = yaml.load(f)
    except:
        with open(device+'.pickle','rb') as f:
            prm = pickle.load(f)
    d.associate(prm)
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{82}\nwdocspar
The device parameter are formatted into messages that will be used to
communicate to the server.    
\nwenddocs{}\nwbegincode{83}\sublabel{NW4Bsmdy-1ydhdJ-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1ydhdJ-1}}}\moddef{Server device parameter loading and formatting~{\nwtagstyle{}\subpageref{NW4Bsmdy-1ydhdJ-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-3}}\nwenddeflinemarkup
def associate(self,prm):
    base_units = np.pi/180
    units = \{'degree': base_units,
             'arcmin': base_units/60,
             'arcsec': base_units/60/60,
             'mas': base_units/60/60/1e3\}
    if 'mirror' in prm:
        self.msg['class_id'] = 'GMT'
        self.msg_args['Start'].update(prm)
        if 'state' in prm:
            self.msg_args['Init']['state'] = \{prm['mirror']:
                                              \{k:np.asarray(v,dtype=np.double) \\
                                               for k,v in prm['state'].items()\}\}
            self.msg_args['Start'].pop('state')
        self.msg_args['Update']['mirror'] = prm['mirror']
        self.msg_args['Update']['inputs'].update(\\
                \{k_i:v_i.data for k_i,v_i in self.inputs.items()\})
    elif 'FEM' in prm:
        self.msg['class_id'] = 'FEM'
        self.msg_args['Start'].update(prm['FEM']['build'])
        self.msg_args['Init'].update(\{'dt':self.tau,
                                      'inputs':list(self.inputs.keys()),
                                      'outputs':list(self.outputs.keys())\})
        self.msg_args['Init'].update(prm['FEM']['reduction'])
        self.msg_args['Update'].update(\\
                \{k_i:v_i.data for k_i,v_i in self.inputs.items()\})
        self.msg_args['Outputs']['outputs'] += [k_o for k_o in self.outputs]
    elif 'wind loads' in prm:
        self.msg['class_id'] = 'WindLoad'
        self.msg_args['Start'].update(prm['wind loads'])
        self.msg_args['Start'].update(\{'fs':1/self.tau\})
        self.msg_args['Outputs']['outputs'] += [k_o for k_o in self.outputs]
    elif 'source' in prm:
        self.msg['class_id'] = 'OP'
        if isinstance(prm['source']['zenith'],dict):
            prm['source']['zenith'] = np.asarray(prm['source']['zenith']['value'],
                                                 dtype=np.double)*\\
                                      units[prm['source']['zenith']['units']]
        if isinstance(prm['source']['azimuth'],dict):
            prm['source']['azimuth'] = np.asarray(prm['source']['azimuth']['value'],
                                                  dtype=np.double)*\\
                                      units[prm['source']['azimuth']['units']]
        prm['source'].update(\{'samplingTime':self.tau*self.sampling_rate\})
        self.msg_args['Start'].update(\{'source_args':prm['source'],
                                       'sensor_class':prm['sensor']['class'],
                                       'sensor_args':\{\},
                                       'calibration_source_args':None,
                                       'calibrate_args':None\})
        if 'source_attributes' in prm:
            src_attr = prm['source_attributes']
            print(src_attr)
            src_attr.update(\{'timeStamp':self.delay*self.tau\})
            if 'rays' in src_attr and \\
               'rot_angle' in  src_attr['rays'] and \\
               isinstance(src_attr['rays']['rot_angle'],dict):
                src_attr['rays']['rot_angle'] = \\
                  np.asarray(src_attr['rays']['rot_angle']['value'])*\\
                   units[src_attr['rays']['rot_angle']['units']]
        else:
            src_attr = \{'timeStamp':self.delay*self.tau\}
        self.msg_args['Start'].update(\{'source_attributes':src_attr\})

        if prm['sensor']['class'] is not None:
            self.msg_args['Start']['sensor_args'].update(prm['sensor']['args'])
            self.msg_args['Start']['calibrate_args'] = prm['sensor']['calibrate_args']
        if 'interaction matrices' in prm:
            self.msg_args['Init'].update(prm['interaction matrices'])
        self.msg_args['Outputs']['outputs'] += [k_o for k_o in self.outputs]
\nwused{\\{NW4Bsmdy-439t7Z-3}}\nwendcode{}\nwbegincode{84}\sublabel{NW4Bsmdy-3kAxOM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3kAxOM-1}}}\moddef{control imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-3kAxOM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-4N1bga-1}}\nwenddeflinemarkup
from scipy import signal
import pickle
\nwused{\\{NW4Bsmdy-4N1bga-1}}\nwendcode{}\nwbegincode{85}\sublabel{NW4Bsmdy-1iFcrn-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1iFcrn-1}}}\moddef{Client device parameter loading and formatting~{\nwtagstyle{}\subpageref{NW4Bsmdy-1iFcrn-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-4}}\nwenddeflinemarkup
def associate(self,prm):
    sys = list(prm.keys())[0] 
    self.system = getattr(control,sys)(**prm[sys])
\nwused{\\{NW4Bsmdy-439t7Z-4}}\nwendcode{}\nwbegindocs{86}\nwdocspar
Next we check if an atmosphere is define
\nwenddocs{}\nwbegindocs{87}\nwdocspar

\subsubsection{Simulation execution}
\label{sec:sim-exec}

Once the parameters are loaded and the drivers linked, we call the drivers {\Tt{}start\nwendquote}
\nwenddocs{}\nwbegincode{88}\sublabel{NW4Bsmdy-p2ZYp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-p2ZYp-1}}}\moddef{starting the drivers~{\nwtagstyle{}\subpageref{NW4Bsmdy-p2ZYp-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
self.__start = map(lambda x: x.start(), self.drivers.values())
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegincode{89}\sublabel{NW4Bsmdy-1ebFFG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1ebFFG-1}}}\moddef{starting the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-1ebFFG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
def push(self):
    self.logger.info('Pushing configuration to server')
    list(self.__start)
    self.pushed = True
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{90}\nwdocspar
and {\Tt{}init\nwendquote} methods:
\nwenddocs{}\nwbegincode{91}\sublabel{NW4Bsmdy-1lxN2y-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1lxN2y-1}}}\moddef{initializing the drivers~{\nwtagstyle{}\subpageref{NW4Bsmdy-1lxN2y-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
self.__init = map(lambda x: x.init(), self.drivers.values())
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegincode{92}\sublabel{NW4Bsmdy-2Jt2yo-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2Jt2yo-1}}}\moddef{initializing the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-2Jt2yo-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
def init(self):
    self.logger.info('Initializing')
    list(self.__init)
    self.initialized = True
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{93}\nwdocspar
Then the {\Tt{}update\nwendquote} and {\Tt{}output\nwendquote} methods are called successively for the total
{\Tt{}duration\nwendquote} of the simulation.
\nwenddocs{}\nwbegincode{94}\sublabel{NW4Bsmdy-3sOZsM-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3sOZsM-1}}}\moddef{running the loop~{\nwtagstyle{}\subpageref{NW4Bsmdy-3sOZsM-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
self.step = self.stepping()
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegincode{95}\sublabel{NW4Bsmdy-4CTiGt-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4CTiGt-1}}}\moddef{stepping through~{\nwtagstyle{}\subpageref{NW4Bsmdy-4CTiGt-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
def stepping(self):
    v = self.drivers.values()
    for l in range(self.N_SAMPLE):
        self.logger.debug('Step #%d',l)
        yield [x.update(l) for x in v] + [x.output(l) for x in v]
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegincode{96}\sublabel{NW4Bsmdy-3jYsn6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3jYsn6-1}}}\moddef{running the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-3jYsn6-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
def run(self):
    if not self.pushed:
        self.push()
    if not self.initialized:
        self.init()
    self.logger.info('Running')
    with Timer():
        for self.__k_step in range(self.N_SAMPLE):
            next(self.step)
    self.terminate()
def _run_(self):
    if not self.pushed:
        self.push()
    if not self.initialized:
        self.init()
    self.logger.info('Running')
    with Timer():
        for self.__k_step in range(self.N_SAMPLE):
            next(self.step)
    self.terminate()
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{97}\nwdocspar
The simulation ends-up with calling the {\Tt{}terminate\nwendquote} methods.
\nwenddocs{}\nwbegincode{98}\sublabel{NW4Bsmdy-1F7pYs-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1F7pYs-1}}}\moddef{terminating the drivers~{\nwtagstyle{}\subpageref{NW4Bsmdy-1F7pYs-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
self.__terminate = map(lambda x: x.terminate(), self.drivers.values())
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegincode{99}\sublabel{NW4Bsmdy-3UROtz-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3UROtz-1}}}\moddef{terminating the simulation~{\nwtagstyle{}\subpageref{NW4Bsmdy-3UROtz-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
def terminate(self):
    self.logger.info('Terminating')
    list(self.__terminate)
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{100}\nwdocspar

\subsection{DOS driver}
\label{sec:dos-driver}
   
The next section is the {\Tt{}drivers\nwendquote} section.
This section lists all the devices that makes the simulation.
There is a many subsections as drivers.
A {\Tt{}drivers\nwendquote} has a unique name {\Tt{}device\ name\nwendquote} that must be matched by a
parameter file of the same name {\Tt{}device\ name\nwendquote}.yaml.
An object is associated to each device.
The object have the following methods: {\Tt{}start\nwendquote},{\Tt{}init\nwendquote},{\Tt{}update\nwendquote},{\Tt{}output\nwendquote}
and {\Tt{}terminate\nwendquote}.
Each device execute first the {\Tt{}start\nwendquote} method followed by the {\Tt{}init\nwendquote} method.
Then after {\Tt{}delay\nwendquote} samples, the {\Tt{}update\nwendquote} method is called at the given
{\Tt{}sampling\ rate\nwendquote} reading its inputs.
Each device inputs is defined by a name and has for properties either a size or
a list with the origin device and origin device output name.
The {\Tt{}update\nwendquote} method is followed by the {\Tt{}output\nwendquote} method.
Each device outputs is defined by a name and has for properties a given sampling frequency and either a size or a list with the input destination device and destination device input name.
\nwenddocs{}\nwbegincode{101}\sublabel{NW4Bsmdy-4eUt8y-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4eUt8y-1}}}\moddef{dos drivers section~{\nwtagstyle{}\subpageref{NW4Bsmdy-4eUt8y-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-438U8x-1}}\nwenddeflinemarkup
drivers:
  device name:
    server: true
    delay: 0 # [sample]
    sampling rate: 1 # [sample]
    inputs:
      input name:
        size: 0
        lien: [device, device output name]
    outputs:
      output name:
        sampling rate: 1 # [sample]
        size: 0
        lien: [device, device input name]
\nwused{\\{NW4Bsmdy-438U8x-1}}\nwendcode{}\nwbegindocs{102}\nwdocspar
The driver module defines classes that are interfaced to devices either of the
server or on the client.
\nwenddocs{}\nwbegincode{103}\sublabel{NW4Bsmdy-18SHJg-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-1}}}\moddef{driver imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-1}}\nwprevnextdefs{\relax}{NW4Bsmdy-18SHJg-2}\nwenddeflinemarkup
import numpy as np
from ruamel.yaml import YAML
yaml=YAML(typ='safe')
import logging
\nwalsodefined{\\{NW4Bsmdy-18SHJg-2}\\{NW4Bsmdy-18SHJg-3}\\{NW4Bsmdy-18SHJg-4}}\nwused{\\{NW4Bsmdy-439t7Z-1}}\nwendcode{}\nwbegincode{104}\sublabel{NW4Bsmdy-439t7Z-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-1}}}\moddef{driver.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-1}}}\endmoddef\nwstartdeflinemarkup\nwprevnextdefs{\relax}{NW4Bsmdy-439t7Z-2}\nwenddeflinemarkup
\LA{}driver imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-1}}\RA{}
logging.basicConfig()
\LA{}IO~{\nwtagstyle{}\subpageref{NW4Bsmdy-3D6dH6-1}}\RA{}
\LA{}Inputs~{\nwtagstyle{}\subpageref{NW4Bsmdy-2F5kqp-1}}\RA{}
\LA{}Outputs~{\nwtagstyle{}\subpageref{NW4Bsmdy-2o1CzV-1}}\RA{}
\nwalsodefined{\\{NW4Bsmdy-439t7Z-2}\\{NW4Bsmdy-439t7Z-3}\\{NW4Bsmdy-439t7Z-4}\\{NW4Bsmdy-439t7Z-5}}\nwnotused{driver.py}\nwendcode{}\nwbegindocs{105}\nwdocspar
All class must have the following methods: {\Tt{}start\nwendquote}, {\Tt{}init\nwendquote}, {\Tt{}update\nwendquote},
{\Tt{}output\nwendquote} and {\Tt{}terminate\nwendquote}.
\nwenddocs{}\nwbegincode{106}\sublabel{NW4Bsmdy-439t7Z-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-2}}}\moddef{driver.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-439t7Z-1}{NW4Bsmdy-439t7Z-3}\nwenddeflinemarkup
class \nwlinkedidentc{Driver}{NW4Bsmdy-439t7Z-2}:
    def __init__(self,tau,tag):
        self.tau = tau
        self.tag = tag
        self.delay = 0
        self.sampling_rate = 1
    def start(self):
        pass
    def init(self):
        pass
    def update(self,_):
        pass
    def output(self,_):
        pass
    def terminate(self):
        pass
\nwindexdefn{\nwixident{Driver}}{Driver}{NW4Bsmdy-439t7Z-2}\eatline
\nwidentdefs{\\{{\nwixident{Driver}}{Driver}}}\nwendcode{}\nwbegindocs{107}\nwdocspar
\subsubsection{Driver inputs/outputs}
\label{sec:driver-io}

Inputs and outputs are saved as dictionaries with the input and output names as
keys and the values being an instance of the {\Tt{}Inputs\nwendquote} and {\Tt{}Outputs\nwendquote} classes.
\nwenddocs{}\nwbegincode{108}\sublabel{NW4Bsmdy-3D6dH6-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3D6dH6-1}}}\moddef{IO~{\nwtagstyle{}\subpageref{NW4Bsmdy-3D6dH6-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-1}}\nwenddeflinemarkup
class \nwlinkedidentc{IO}{NW4Bsmdy-3D6dH6-1}:
    def __init__(self,tag,size=0, lien=None, logs=None):
        self.logger = logging.getLogger(tag)
        self.logger.setLevel(logging.INFO)
        self.size = size
        self.data = np.zeros(size)
        self.lien = lien
        self.logs = logs
\nwindexdefn{\nwixident{IO}}{IO}{NW4Bsmdy-3D6dH6-1}\eatline
\nwused{\\{NW4Bsmdy-439t7Z-1}}\nwidentdefs{\\{{\nwixident{IO}}{IO}}}\nwendcode{}\nwbegincode{109}\sublabel{NW4Bsmdy-2F5kqp-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2F5kqp-1}}}\moddef{Inputs~{\nwtagstyle{}\subpageref{NW4Bsmdy-2F5kqp-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-1}}\nwenddeflinemarkup
class \nwlinkedidentc{Input}{NW4Bsmdy-2F5kqp-1}(\nwlinkedidentc{IO}{NW4Bsmdy-3D6dH6-1}):
    def __init__(self,*args,**kwargs):
        \nwlinkedidentc{IO}{NW4Bsmdy-3D6dH6-1}.__init__(self,*args,**kwargs)
    \LA{}input linking~{\nwtagstyle{}\subpageref{NW4Bsmdy-Lc6U0-1}}\RA{}
\nwindexdefn{\nwixident{Input}}{Input}{NW4Bsmdy-2F5kqp-1}\eatline
\nwused{\\{NW4Bsmdy-439t7Z-1}}\nwidentdefs{\\{{\nwixident{Input}}{Input}}}\nwidentuses{\\{{\nwixident{IO}}{IO}}}\nwindexuse{\nwixident{IO}}{IO}{NW4Bsmdy-2F5kqp-1}\nwendcode{}\nwbegindocs{110}and {\Tt{}Outputs\nwendquote} classes.
\nwenddocs{}\nwbegincode{111}\sublabel{NW4Bsmdy-2o1CzV-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-2o1CzV-1}}}\moddef{Outputs~{\nwtagstyle{}\subpageref{NW4Bsmdy-2o1CzV-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-1}}\nwenddeflinemarkup
class \nwlinkedidentc{Output}{NW4Bsmdy-2o1CzV-1}(\nwlinkedidentc{IO}{NW4Bsmdy-3D6dH6-1}):
    def __init__(self,*args,sampling_rate=1,**kwargs):
        \nwlinkedidentc{IO}{NW4Bsmdy-3D6dH6-1}.__init__(self,*args,**kwargs)
        self.sampling_rate = sampling_rate
    \LA{}output linking~{\nwtagstyle{}\subpageref{NW4Bsmdy-47UBg5-1}}\RA{}
\nwindexdefn{\nwixident{Output}}{Output}{NW4Bsmdy-2o1CzV-1}\eatline
\nwused{\\{NW4Bsmdy-439t7Z-1}}\nwidentdefs{\\{{\nwixident{Output}}{Output}}}\nwidentuses{\\{{\nwixident{IO}}{IO}}}\nwindexuse{\nwixident{IO}}{IO}{NW4Bsmdy-2o1CzV-1}\nwendcode{}\nwbegindocs{112}        
\subsubsection{Server}
\label{sec:driver.server}


The {\Tt{}\nwlinkedidentq{Server}{NWD4Bsmdy-1}\nwendquote} class is the interface with the server where the devices are CEO objects.
\nwenddocs{}\nwbegincode{113}\sublabel{NW4Bsmdy-439t7Z-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-3}}}\moddef{driver.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-439t7Z-2}{NW4Bsmdy-439t7Z-4}\nwenddeflinemarkup
class \nwlinkedidentc{Server}{NWD4Bsmdy-1}(\nwlinkedidentc{Driver}{NW4Bsmdy-439t7Z-2}):
    def __init__(self,tau,tag,logs,server,delay=0,sampling_rate=1,
             verbose=logging.INFO,**kwargs):
        \LA{}commom server/client driver~{\nwtagstyle{}\subpageref{NW4Bsmdy-1QBpEW-1}}\RA{}
        self.server        = server
        self.msg = \{'class_id':'',
                    'method_id':'',
                    'args':\{\}\}
        self.msg_args = \{'Start':\{\},
                    'Init':\{\},
                    'Update':\{'inputs':\{\}\},
                    'Outputs':\{'outputs':[]\},
                    'Terminate':\{'args':None\}\}

    \LA{}Server methods~{\nwtagstyle{}\subpageref{NW4Bsmdy-srxv1-1}}\RA{}

    \LA{}Server device parameter loading and formatting~{\nwtagstyle{}\subpageref{NW4Bsmdy-1ydhdJ-1}}\RA{}
\nwidentuses{\\{{\nwixident{Driver}}{Driver}}\\{{\nwixident{Server}}{Server}}}\nwindexuse{\nwixident{Driver}}{Driver}{NW4Bsmdy-439t7Z-3}\nwindexuse{\nwixident{Server}}{Server}{NW4Bsmdy-439t7Z-3}\nwendcode{}\nwbegindocs{114}\nwdocspar
with
\nwenddocs{}\nwbegincode{115}\sublabel{NW4Bsmdy-1QBpEW-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-1QBpEW-1}}}\moddef{commom server/client driver~{\nwtagstyle{}\subpageref{NW4Bsmdy-1QBpEW-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-3}\\{NW4Bsmdy-439t7Z-4}}\nwenddeflinemarkup
\nwlinkedidentc{Driver}{NW4Bsmdy-439t7Z-2}.__init__(self,tau,tag)
self.logger = logging.getLogger(tag)
self.logger.setLevel(verbose)
self.delay         = delay
self.sampling_rate = sampling_rate
self.inputs        = \{\}
if 'inputs' in kwargs:
    for k,v in kwargs['inputs'].items():
        self.logger.info('New input: %s',k)
        self.inputs[k] = \nwlinkedidentc{Input}{NW4Bsmdy-2F5kqp-1}(k,**v)
self.outputs       = \{\}
if 'outputs' in kwargs:
    for k,v in kwargs['outputs'].items():
        self.logger.info('New output: %s',k)
        if not 'sampling_rate' in v:
            v['sampling_rate']=self.sampling_rate
        if v['sampling_rate']<self.sampling_rate:
            if v['sampling_rate']!=1:
                self.logger.error('The driver output rate cannot be less than the update rate!')
            self.logger.warning('Changing the output rate to match the update rate!')
            v['sampling_rate'] = self.sampling_rate
        if 'logs' in v:
            logs.add(tag,k,v['logs']['decimation'],self.delay)
            if v['logs']['decimation']<v['sampling_rate']:
                if v['logs']['decimation']!=1:
                    self.logger.error('The log decimation rate cannot be less than the output rate!')
                self.logger.warning('Changing the decimation rate to match the output rate!')
                v['logs']['decimation'] = v['sampling_rate']
            v['logs'] = logs.entries[tag][k]
            self.logger.info('Output logged in!')
        self.outputs[k] = \nwlinkedidentc{Output}{NW4Bsmdy-2o1CzV-1}(k,**v)
\nwused{\\{NW4Bsmdy-439t7Z-3}\\{NW4Bsmdy-439t7Z-4}}\nwidentuses{\\{{\nwixident{Driver}}{Driver}}\\{{\nwixident{Input}}{Input}}\\{{\nwixident{Output}}{Output}}}\nwindexuse{\nwixident{Driver}}{Driver}{NW4Bsmdy-1QBpEW-1}\nwindexuse{\nwixident{Input}}{Input}{NW4Bsmdy-1QBpEW-1}\nwindexuse{\nwixident{Output}}{Output}{NW4Bsmdy-1QBpEW-1}\nwendcode{}\nwbegindocs{116}\nwdocspar
\nosublabel{NWD4Bsmdy-1}\nwindexdefn{\nwixident{Server}}{Server}{NWD4Bsmdy-1}%
The inherited {\Tt{}\nwlinkedidentq{Server}{NWD4Bsmdy-1}\nwendquote} method are:
\nwenddocs{}\nwbegincode{117}\sublabel{NW4Bsmdy-srxv1-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-srxv1-1}}}\moddef{Server methods~{\nwtagstyle{}\subpageref{NW4Bsmdy-srxv1-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-3}}\nwenddeflinemarkup
def start(self):
    self.logger.debug('Starting!')
    m = 'Start'
    \LA{}client-server exchange~{\nwtagstyle{}\subpageref{NW4Bsmdy-3xgfsG-1}}\RA{}
    self.msg['class_id'] = reply
    self.logger.info('%s',reply)
def init(self):
    self.logger.debug('Initializing!')
    m = 'Init'
    \LA{}client-server exchange~{\nwtagstyle{}\subpageref{NW4Bsmdy-3xgfsG-1}}\RA{}
    self.logger.info('%s',reply)
def update(self,step):
    if step>=self.delay and (step-self.delay)%self.sampling_rate==0:
        self.logger.debug('Updating!')
        m = 'Update'
        \LA{}client-server exchange~{\nwtagstyle{}\subpageref{NW4Bsmdy-3xgfsG-1}}\RA{}
def output(self,step):
    if step>=self.delay:
            m = 'Outputs'
            if self.msg_args[m]['outputs']:
                \LA{}client-server exchange~{\nwtagstyle{}\subpageref{NW4Bsmdy-3xgfsG-1}}\RA{}
                #self.logger.debug("Reply: %s",reply)
                for k,v in self.outputs.items():
                    if (step-self.delay)%v.sampling_rate==0:
                        self.logger.debug('Outputing %s!',k)
                        try:
                            v.data[...] = np.asarray(reply[k]).reshape(v.size)
                        except ValueError:
                            self.logger.warning('Resizing %s!',k)
                            __red = np.asarray(reply[k])
                            v.size = __red.shape
                            v.data = np.zeros(__red.shape)
                            v.data[...] = __red
                        if v.logs is not None and (step-self.delay)%v.logs.decimation==0:
                            self.logger.debug('LOGGING')
                            v.logs.add(v.data.copy())

def terminate(self):
    self.logger.debug('Terminating!')
    m = 'Terminate'
    \LA{}client-server exchange~{\nwtagstyle{}\subpageref{NW4Bsmdy-3xgfsG-1}}\RA{}
    self.logger.info(reply)
\nwused{\\{NW4Bsmdy-439t7Z-3}}\nwendcode{}\nwbegindocs{118}\nwdocspar
Each method communicates with the server using the same protocol
\nwenddocs{}\nwbegincode{119}\sublabel{NW4Bsmdy-3xgfsG-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3xgfsG-1}}}\moddef{client-server exchange~{\nwtagstyle{}\subpageref{NW4Bsmdy-3xgfsG-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-srxv1-1}}\nwenddeflinemarkup
self.msg['method_id'] = m
self.msg['args'].update(self.msg_args[m])
self.server._send_(self.msg)
self.msg['method_id'] = ''
self.msg['args'].clear()
reply = self.server._recv_()
\nwused{\\{NW4Bsmdy-srxv1-1}}\nwendcode{}\nwbegindocs{120}\nwdocspar
\subsubsection{Client}
\label{sec:driver.client}


The {\Tt{}\nwlinkedidentq{Client}{NW4Bsmdy-439t7Z-4}\nwendquote} class is the interface with the client devices such as temporal controllers.
\nwenddocs{}\nwbegincode{121}\sublabel{NW4Bsmdy-439t7Z-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-4}}}\moddef{driver.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-439t7Z-3}{NW4Bsmdy-439t7Z-5}\nwenddeflinemarkup
class \nwlinkedidentc{Client}{NW4Bsmdy-439t7Z-4}(\nwlinkedidentc{Driver}{NW4Bsmdy-439t7Z-2}):
    def __init__(self,tau,tag,logs,delay=0,sampling_rate=1,
                 verbose=logging.INFO,**kwargs):
        \LA{}commom server/client driver~{\nwtagstyle{}\subpageref{NW4Bsmdy-1QBpEW-1}}\RA{}
        self.system = None

    \LA{}Client methods~{\nwtagstyle{}\subpageref{NW4Bsmdy-3MNiaD-1}}\RA{}

    \LA{}Client device parameter loading and formatting~{\nwtagstyle{}\subpageref{NW4Bsmdy-1iFcrn-1}}\RA{}
\nwindexdefn{\nwixident{Client}}{Client}{NW4Bsmdy-439t7Z-4}\eatline
\nwidentdefs{\\{{\nwixident{Client}}{Client}}}\nwidentuses{\\{{\nwixident{Driver}}{Driver}}}\nwindexuse{\nwixident{Driver}}{Driver}{NW4Bsmdy-439t7Z-4}\nwendcode{}\nwbegindocs{122}In debug mode, the norm of the vector $u$, $y$ and $x$ are logged at each time
step into a Panda dataframe.
\nwenddocs{}\nwbegincode{123}\sublabel{NW4Bsmdy-18SHJg-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-2}}}\moddef{driver imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-1}}\nwprevnextdefs{NW4Bsmdy-18SHJg-1}{NW4Bsmdy-18SHJg-3}\nwenddeflinemarkup
import pandas as pd
\nwused{\\{NW4Bsmdy-439t7Z-1}}\nwendcode{}\nwbegincode{124}\sublabel{NW4Bsmdy-4NH9uP-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4NH9uP-1}}}\moddef{client debug mode (init)~{\nwtagstyle{}\subpageref{NW4Bsmdy-4NH9uP-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
if self.logger.level==10:
    self.UYX = pd.DataFrame(columns=['|U|','|Y|','|X|'])
\nwnotused{client debug mode (init)}\nwendcode{}\nwbegindocs{125}\nwdocspar
The dataframe is updated at each update call:
\nwenddocs{}\nwbegincode{126}\sublabel{NW4Bsmdy-18SHJg-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-3}}}\moddef{driver imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-1}}\nwprevnextdefs{NW4Bsmdy-18SHJg-2}{NW4Bsmdy-18SHJg-4}\nwenddeflinemarkup
from numpy.linalg import norm
\nwused{\\{NW4Bsmdy-439t7Z-1}}\nwendcode{}\nwbegincode{127}\sublabel{NW4Bsmdy-43YXBe-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-43YXBe-1}}}\moddef{client debug mode (update)~{\nwtagstyle{}\subpageref{NW4Bsmdy-43YXBe-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
if self.logger.level==10:
    self.UYX.loc[step] = [norm(u),
                          norm(self.__yout),
                          norm(self.__xout)]
\nwnotused{client debug mode (update)}\nwendcode{}\nwbegindocs{128}\nwdocspar
The dynamic behavior of the {\Tt{}\nwlinkedidentq{Client}{NW4Bsmdy-439t7Z-4}\nwendquote} is capture in the following classes:
\nwenddocs{}\nwbegincode{129}\sublabel{NW4Bsmdy-3MNiaD-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-3MNiaD-1}}}\moddef{Client methods~{\nwtagstyle{}\subpageref{NW4Bsmdy-3MNiaD-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-4}}\nwenddeflinemarkup
def start(self):
    self.logger.debug('Starting!')
def init(self):
    self.logger.debug('Initializing!')
    self.system.init()
def update(self,step):
    if step>=self.delay and (step-self.delay)%self.sampling_rate==0:
        self.logger.debug('Updating!')
        u = np.hstack([_.data.reshape(1,-1) for _  in self.inputs.values()])
        self.system.update(u)
        self.logger.debug('u: %s',u)

def output(self,step):
    if step>=self.delay:
        a = 0
        b = 0
        for k,v in self.outputs.items():
            if (step-self.delay)%v.sampling_rate==0:
                self.logger.debug('Outputing %s!',k)
                b = a + v.data.size
                self.logger.debug('%s [%s]: [%d,%d]',k,v.size,a,b)
                v.data[...] = self.system.output()[0,a:b].reshape(v.size)
                a = b
                if v.logs is not None and (step-self.delay)%v.logs.decimation==0:
                    self.logger.debug('LOGGING')
                    v.logs.add(v.data.copy())


def terminate(self):
    self.logger.debug('Terminating!')
\nwused{\\{NW4Bsmdy-439t7Z-4}}\nwendcode{}\nwbegindocs{130}\nwdocspar

\paragraph{System}

\nwenddocs{}\nwbegincode{131}\sublabel{NW4Bsmdy-18SHJg-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-4}}}\moddef{driver imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-18SHJg-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-439t7Z-1}}\nwprevnextdefs{NW4Bsmdy-18SHJg-3}{\relax}\nwenddeflinemarkup
from . import control
\nwused{\\{NW4Bsmdy-439t7Z-1}}\nwendcode{}\nwbegindocs{132}\nwdocspar
\nwenddocs{}\nwbegincode{133}\sublabel{NW4Bsmdy-4N1bga-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4N1bga-1}}}\moddef{control.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-4N1bga-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
\LA{}control imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-3kAxOM-1}}\RA{}
from .mpc_driver import MPC
from .MountController import Mount
import numpy as np
class System:
    def __init__(self,**kwargs):
        if 'transfer function' in kwargs:
            self.system = signal.dlti(kwargs['transfer function']['num'],
                                      kwargs['transfer function']['denom'])
        elif 'zeros poles gain' in kwargs:
            self.system = signal.dlti(kwargs['transfer function']['zeros'],
                                      Kwargs['transfer function']['poles'],
                                      kwargs['transfer function']['gain'])
        else:
            raise Exception("System should be of the type "+\\
                            "'transfer function' or 'zeros poles gains'")
        self.__xout = np.zeros(0)
        self.__yout = np.zeros(0)

    def init(self):
        self.system = self.system._as_ss()
        self.__xout = np.zeros((1,self.system.A.shape[0]))
        self.__yout = np.zeros((1, self.system.C.shape[0]))

    def update(self,u):
        self.__yout = np.dot(self.system.C, self.__xout) + np.dot(self.system.D, u)
        self.__xout = np.dot(self.system.A, self.__xout) + np.dot(self.system.B, u)

    def output(self):
        return self.__yout
\nwnotused{control.py}\nwendcode{}\nwbegindocs{134}\nwdocspar

\subsubsection{Atmosphere}
\label{sec:driver.atmosphere}


A special driver is the atmosphere driver that is used to instantiate an
atmosphere object on CEO server
\nwenddocs{}\nwbegincode{135}\sublabel{NW4Bsmdy-439t7Z-5}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-5}}}\moddef{driver.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-439t7Z-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-439t7Z-4}{\relax}\nwenddeflinemarkup
class \nwlinkedidentc{Atmosphere}{NW4Bsmdy-439t7Z-5}(\nwlinkedidentc{Driver}{NW4Bsmdy-439t7Z-2}):
    def __init__(self,tau,tag,server,verbose=logging.INFO,**kwargs):
        \nwlinkedidentc{Driver}{NW4Bsmdy-439t7Z-2}.__init__(self,tau,tag)
        self.logger = logging.getLogger(tag)
        self.logger.setLevel(verbose)
        self.server = server
        self.inputs = \{\}
        self.outputs= \{\}
        self.msg    = \{'class_id':'ATM',
                       'method_id':'Start',
                       'args':\{\}\}
    def start(self):
        self.server._send_(self.msg)
        reply = self.server._recv_()
        self.logger.info('%s',reply)

    def terminate(self):
        self.server._send_(\{'class_id':'ATM',
                            'method_id':'Terminate',
                            'args':\{'args':None\}\})
        reply = self.server._recv_()
        self.logger.info('%s',reply)

    def associate(self,prm):
        self.msg['args'].update(prm)
\nwindexdefn{\nwixident{Atmosphere}}{Atmosphere}{NW4Bsmdy-439t7Z-5}\eatline
\nwidentdefs{\\{{\nwixident{Atmosphere}}{Atmosphere}}}\nwidentuses{\\{{\nwixident{Driver}}{Driver}}}\nwindexuse{\nwixident{Driver}}{Driver}{NW4Bsmdy-439t7Z-5}\nwendcode{}\nwbegindocs{136}\nwdocspar
\subsection{Logs}
\label{sec:logs}

Driver output data can be logged in using the {\Tt{}Logs\nwendquote} class:
\nwenddocs{}\nwbegincode{137}\sublabel{NW4Bsmdy-42xnBU-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-2}}}\moddef{dos.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-42xnBU-1}{NW4Bsmdy-42xnBU-3}\nwenddeflinemarkup
class Entry:
    def __init__(self,tau,decimation,delay):
        self.tau = tau
        self.decimation = decimation
        self.delay = delay
        self.data = []
    def add(self,value):
        self.data += [value]
    @property
    def timeSeries(self):
        time   = (np.arange(len(self.data))*self.decimation+self.delay)*self.tau
        values = np.vstack(self.data) if self.data[0].ndim<2 else np.dstack(self.data)
        return time,values
class Logs:
    def __init__(self,sampling_time=0,logs_repo=''):
        self.sampling_time = sampling_time
        self.logs_repo = logs_repo
        self.entries = \{\}
    def add(self,driver,output,decimation,delay=0):
        if driver in self.entries:
            self.entries[driver][output] = Entry(self.sampling_time,decimation,delay)
        else:
            self.entries[driver] = \{output:Entry(self.sampling_time,decimation,delay)\}
    def __repr__(self):
        if self.entries:
            line = ["The 'logs' has \{\} entries:".format(self.N_entries)]
            for d in self.entries:
                line += [" * \{\}".format(d)]
                for k,e in enumerate(self.entries[d]):
                    v = self.entries[d][e]
                    if v.data:
                        line += ["   \{0\}. \{1\}: \{2\}x\{3\}".format(k+1,e,v.data[0].shape,len(v.data))]
                    else:
                        line += ["   \{0\}. \{1\}".format(k+1,e)]
        else:
            line = ["The 'logs' has no entries!"]
        return "\\n".join(line)
    def dump(self):
        filename = os.path.join(self.logs_repo,'logs.pickle')
        data = \{'sampling_time':self.sampling_time\}
        data.update(self.entries)
        with open(filename,'wb') as f:
            pickle.dump(data,f)
    def load(self):
        filename = os.path.join(self.logs_repo,'logs.pickle')
        with open(filename,'rb') as f:
            data = pickle.load(f)
        self.sampling_time = data['sampling_time']
        data.pop('sampling_time')
        self.entries.update(data)
    @property
    def N_entries(self):
        return sum([len(_) for _ in self.entries.values()])
\nwendcode{}\nwbegindocs{138}\nwdocspar
\subsection{The broker}
\label{sec:client-broker}

\nwenddocs{}\nwbegincode{139}\sublabel{NW4Bsmdy-4SxboR-2}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-2}}}\moddef{dos imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwprevnextdefs{NW4Bsmdy-4SxboR-1}{NW4Bsmdy-4SxboR-3}\nwenddeflinemarkup
import zmq
import pickle
import zlib
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{140}\nwdocspar
\nwenddocs{}\nwbegincode{141}\sublabel{NW4Bsmdy-42xnBU-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-3}}}\moddef{dos.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-42xnBU-2}{NW4Bsmdy-42xnBU-4}\nwenddeflinemarkup
class broker:

    def __init__(self,IP):
        self.logger = logging.getLogger(self.__class__.__name__)
        self.context = zmq.Context()
        self.logger.info("Connecting to server...")
        self.socket = self.context.socket(zmq.REQ)
        self.socket.connect("tcp://\{\}:3650".format(IP))
        self._send_("Acknowledging connection from SIMCEO client!")
        print(self._recv_())

    def __del__(self):
        self.logger.info('Disconnecting from server!')
        self.socket.close()
        self.context.term()

    def _send_(self,obj,protocol=-1,flags=0):
        pobj = pickle.dumps(obj,protocol)
        zobj = zlib.compress(pobj)
        self.socket.send(zobj, flags=flags)

    def _recv_(self,flags=0):
        zobj = self.socket.recv(flags)
        pobj = zlib.decompress(zobj)
        return pickle.loads(pobj)

\nwendcode{}\nwbegindocs{142}\nwdocspar

\subsection{Timing diagram}
\label{sec:timing-diag}

A timing diagram can be generated with the {\Tt{}diagram\nwendquote} method.
It is produced with the {\Tt{}graphviz\nwendquote} module.
\nwenddocs{}\nwbegincode{143}\sublabel{NW4Bsmdy-4SxboR-3}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-3}}}\moddef{dos imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwprevnextdefs{NW4Bsmdy-4SxboR-2}{NW4Bsmdy-4SxboR-4}\nwenddeflinemarkup
from graphviz import Digraph
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{144}\nwdocspar
\nwenddocs{}\nwbegincode{145}\sublabel{NW4Bsmdy-xTFQY-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-xTFQY-1}}}\moddef{timing diagram~{\nwtagstyle{}\subpageref{NW4Bsmdy-xTFQY-1}}}\endmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwenddeflinemarkup
def diagram(self,**kwargs):
    def add_item(sample_rate,driver_name,method):
        if not sample_rate in sampling:
            sampling[sample_rate] = \{\}
        if not driver_name in sampling[sample_rate]:
            sampling[sample_rate][driver_name] = [method]
        else:
            sampling[sample_rate][driver_name] += [method]
    def make_nodes(_s_):
        if not np.isinf(_s_):
            ss = str(_s_)
            c = Digraph(ss)
            c.attr(rank='same')
            c.node(ss,time_label(_s_))
            [c.node(ss+'_'+_,make_label(_,sampling[_s_][_])) for _ in sampling[_s_]]
            main.subgraph(c)
    def make_label(d,dv):
        label = "<TR><TD><B>\{\}</B></TD></TR>".format(d)
        for v in dv:
            label += '''<TR><TD PORT="\{0\}_\{1\}">\{1\}</TD></TR>'''.format(d,v)
        return '''<<TABLE BORDER="0" CELLBORDER="1">\{\}</TABLE>>'''.format(label)
    def search_method(d,m):
        for s in sampling:
            if d in sampling[s]:
                if m in sampling[s][d]:
                    return '\{0\}_\{1\}:\{1\}_\{2\}'.format(str(s),d,m)
    def time_label(n):
        nu = self.cfg['simulation']['sampling frequency']
        t = n/nu
        if t<1:
            return '\{:.1f\}ms'.format(t*1e3)
        else:
            return '\{:.1f\}s'.format(t)

    main = Digraph(format='png', node_attr=\{'shape': 'plaintext'\})

    sampling = \{\}
    for dk in self.drivers:
        if not dk=='atmosphere':
            self.logger.debug("Timing:%s",dk)
            d = self.drivers[dk]
            if d.delay>0:
                add_item(d.delay,dk,'delay')
            if np.isinf(d.sampling_rate):
                add_item(d.delay,dk,'update')
            else:
                add_item(d.sampling_rate,dk,'update')
            for ok in d.outputs:
                o = d.outputs[ok]
                if np.isinf(o.sampling_rate):
                    add_item(d.delay,dk,ok)
                else:
                    add_item(o.sampling_rate,dk,ok)

    s = sorted(sampling)
    [make_nodes(_) for _ in s]

    for k in range(1,len(s)):
        if not np.isinf(s[k]):
            main.edge(str(s[k-1]),str(s[k]))

    for s in sampling:
        for d in sampling[s]:
            m = sampling[s][d]
            if not (len(m)==1 and m[0]=='delay'):
                for ik in self.drivers[d].inputs:
                    data = self.drivers[d].inputs[ik]
                    if data.lien is not None:
                        main.edge(search_method(data.lien[0],data.lien[1]),
                                  '\{0\}_\{1\}:\{1\}_update'.format(str(s),d))
                for ok in self.drivers[d].outputs:
                    data = self.drivers[d].outputs[ok]
                    if data.lien is not None:
                        main.edge('\{0\}_\{1\}:\{1\}_\{2\}'.format(str(s),d,ok),
                                  search_method(data.lien[0],'update'))

    if kwargs:
        main.render(**kwargs)
    else:
        return sampling,main
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{146}\nwdocspar

\subsection{Main}
\label{sec:dos.main}

\nwenddocs{}\nwbegincode{147}\sublabel{NW4Bsmdy-4SxboR-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-4}}}\moddef{dos imports~{\nwtagstyle{}\subpageref{NW4Bsmdy-4SxboR-1}}}\plusendmoddef\nwstartdeflinemarkup\nwusesondefline{\\{NW4Bsmdy-42xnBU-1}}\nwprevnextdefs{NW4Bsmdy-4SxboR-3}{\relax}\nwenddeflinemarkup
import sys
\nwused{\\{NW4Bsmdy-42xnBU-1}}\nwendcode{}\nwbegindocs{148}\nwdocspar
\nwenddocs{}\nwbegincode{149}\sublabel{NW4Bsmdy-42xnBU-4}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-4}}}\moddef{dos.py~{\nwtagstyle{}\subpageref{NW4Bsmdy-42xnBU-1}}}\plusendmoddef\nwstartdeflinemarkup\nwprevnextdefs{NW4Bsmdy-42xnBU-3}{\relax}\nwenddeflinemarkup

if __name__=="__main__":

    import matplotlib.pyplot as plt

    #dospath = sys.argv[1]
    dospath = 'dos/M2TT'
    sim = DOS(dospath,verbose=logging.INFO,show_timing=2)
    sim._run_()
    fig,ax = plt.subplots()
    ax.plot(*sim.logs.entries['science']['segment_tiptilt'].timeSeries,'.-')
    ax.grid()
    ax.set_xlabel('Time [s]')
    ax.set_ylabel('Seg. TT. [arcsec]')
    plt.show()
\nwendcode{}\nwbegindocs{150}\nwdocspar

\section{SIMCEO Service}
\label{sec:service}

\subsection{Script}
\label{sec:service.script}

\nwenddocs{}\nwbegincode{151}\sublabel{NW4Bsmdy-oRqQe-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-oRqQe-1}}}\moddef{simceo~{\nwtagstyle{}\subpageref{NW4Bsmdy-oRqQe-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
#!/bin/sh
echo "STARTING SIMCEO SERVICE"
/usr/bin/env LD_LIBRARY_PATH=/usr/local/cuda/lib64 PYTHONPATH=/home/ubuntu/CEO/python/ /home/ubuntu/anaconda3/bin/python /home/ubuntu/SIMCEO/simceo.py
\nwnotused{simceo}\nwendcode{}\nwbegindocs{152}\nwdocspar

\subsection{Service}
\label{sec:service.service}

\nwenddocs{}\nwbegincode{153}\sublabel{NW4Bsmdy-14v388-1}\nwmargintag{{\nwtagstyle{}\subpageref{NW4Bsmdy-14v388-1}}}\moddef{simceo.service~{\nwtagstyle{}\subpageref{NW4Bsmdy-14v388-1}}}\endmoddef\nwstartdeflinemarkup\nwenddeflinemarkup
[Unit]
Description=SIMCEO SERVER

[Service]
ExecStart=/bin/su ubuntu -c "/home/ubuntu/bin/simceo"

[Install]
WantedBy=multi-user.target
\nwnotused{simceo.service}\nwendcode{}

\nwixlogsorted{c}{{broker}{NW4Bsmdy-2zgnz8-1}{\nwixu{NW4Bsmdy-3TXSTG-1}\nwixd{NW4Bsmdy-2zgnz8-1}}}%
\nwixlogsorted{c}{{broker get item}{NW4Bsmdy-2erBDY-1}{\nwixu{NW4Bsmdy-2zgnz8-1}\nwixd{NW4Bsmdy-2erBDY-1}}}%
\nwixlogsorted{c}{{broker run}{NW4Bsmdy-2eBAe0-1}{\nwixu{NW4Bsmdy-2zgnz8-1}\nwixd{NW4Bsmdy-2eBAe0-1}}}%
\nwixlogsorted{c}{{broker run details}{NW4Bsmdy-PmwVg-1}{\nwixu{NW4Bsmdy-2eBAe0-1}\nwixd{NW4Bsmdy-PmwVg-1}\nwixd{NW4Bsmdy-PmwVg-2}\nwixd{NW4Bsmdy-PmwVg-3}\nwixd{NW4Bsmdy-PmwVg-4}}}%
\nwixlogsorted{c}{{CalibrationMatrix}{NW4Bsmdy-3jZIZN-1}{\nwixu{NW4Bsmdy-3TXSTG-1}\nwixd{NW4Bsmdy-3jZIZN-1}}}%
\nwixlogsorted{c}{{check parameter file existence}{NW4Bsmdy-1qDwLh-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-1qDwLh-1}}}%
\nwixlogsorted{c}{{client debug mode (init)}{NW4Bsmdy-4NH9uP-1}{\nwixd{NW4Bsmdy-4NH9uP-1}}}%
\nwixlogsorted{c}{{client debug mode (update)}{NW4Bsmdy-43YXBe-1}{\nwixd{NW4Bsmdy-43YXBe-1}}}%
\nwixlogsorted{c}{{Client device parameter loading and formatting}{NW4Bsmdy-1iFcrn-1}{\nwixd{NW4Bsmdy-1iFcrn-1}\nwixu{NW4Bsmdy-439t7Z-4}}}%
\nwixlogsorted{c}{{Client methods}{NW4Bsmdy-3MNiaD-1}{\nwixu{NW4Bsmdy-439t7Z-4}\nwixd{NW4Bsmdy-3MNiaD-1}}}%
\nwixlogsorted{c}{{client-server exchange}{NW4Bsmdy-3xgfsG-1}{\nwixu{NW4Bsmdy-srxv1-1}\nwixd{NW4Bsmdy-3xgfsG-1}}}%
\nwixlogsorted{c}{{commom server/client driver}{NW4Bsmdy-1QBpEW-1}{\nwixu{NW4Bsmdy-439t7Z-3}\nwixd{NW4Bsmdy-1QBpEW-1}\nwixu{NW4Bsmdy-439t7Z-4}}}%
\nwixlogsorted{c}{{control imports}{NW4Bsmdy-3kAxOM-1}{\nwixd{NW4Bsmdy-3kAxOM-1}\nwixu{NW4Bsmdy-4N1bga-1}}}%
\nwixlogsorted{c}{{control.py}{NW4Bsmdy-4N1bga-1}{\nwixd{NW4Bsmdy-4N1bga-1}}}%
\nwixlogsorted{c}{{device to driver association}{NW4Bsmdy-4A0PIB-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-4A0PIB-1}}}%
\nwixlogsorted{c}{{dos drivers section}{NW4Bsmdy-4eUt8y-1}{\nwixu{NW4Bsmdy-438U8x-1}\nwixd{NW4Bsmdy-4eUt8y-1}}}%
\nwixlogsorted{c}{{dos imports}{NW4Bsmdy-4SxboR-1}{\nwixd{NW4Bsmdy-4SxboR-1}\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-4SxboR-2}\nwixd{NW4Bsmdy-4SxboR-3}\nwixd{NW4Bsmdy-4SxboR-4}}}%
\nwixlogsorted{c}{{dos simulation section}{NW4Bsmdy-2KRSGK-1}{\nwixu{NW4Bsmdy-438U8x-1}\nwixd{NW4Bsmdy-2KRSGK-1}}}%
\nwixlogsorted{c}{{dos.py}{NW4Bsmdy-42xnBU-1}{\nwixd{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-42xnBU-2}\nwixd{NW4Bsmdy-42xnBU-3}\nwixd{NW4Bsmdy-42xnBU-4}}}%
\nwixlogsorted{c}{{dos.yaml}{NW4Bsmdy-438U8x-1}{\nwixd{NW4Bsmdy-438U8x-1}}}%
\nwixlogsorted{c}{{driver imports}{NW4Bsmdy-18SHJg-1}{\nwixd{NW4Bsmdy-18SHJg-1}\nwixu{NW4Bsmdy-439t7Z-1}\nwixd{NW4Bsmdy-18SHJg-2}\nwixd{NW4Bsmdy-18SHJg-3}\nwixd{NW4Bsmdy-18SHJg-4}}}%
\nwixlogsorted{c}{{driver.py}{NW4Bsmdy-439t7Z-1}{\nwixd{NW4Bsmdy-439t7Z-1}\nwixd{NW4Bsmdy-439t7Z-2}\nwixd{NW4Bsmdy-439t7Z-3}\nwixd{NW4Bsmdy-439t7Z-4}\nwixd{NW4Bsmdy-439t7Z-5}}}%
\nwixlogsorted{c}{{init.py}{NW4Bsmdy-zxoFq-1}{\nwixd{NW4Bsmdy-zxoFq-1}}}%
\nwixlogsorted{c}{{initializing the drivers}{NW4Bsmdy-1lxN2y-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-1lxN2y-1}}}%
\nwixlogsorted{c}{{initializing the simulation}{NW4Bsmdy-2Jt2yo-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-2Jt2yo-1}}}%
\nwixlogsorted{c}{{input linking}{NW4Bsmdy-Lc6U0-1}{\nwixd{NW4Bsmdy-Lc6U0-1}\nwixu{NW4Bsmdy-2F5kqp-1}}}%
\nwixlogsorted{c}{{Inputs}{NW4Bsmdy-2F5kqp-1}{\nwixu{NW4Bsmdy-439t7Z-1}\nwixd{NW4Bsmdy-2F5kqp-1}}}%
\nwixlogsorted{c}{{IO}{NW4Bsmdy-3D6dH6-1}{\nwixu{NW4Bsmdy-439t7Z-1}\nwixd{NW4Bsmdy-3D6dH6-1}}}%
\nwixlogsorted{c}{{IO linking}{NW4Bsmdy-2BoyHb-1}{\nwixd{NW4Bsmdy-2BoyHb-1}\nwixu{NW4Bsmdy-Lc6U0-1}\nwixu{NW4Bsmdy-47UBg5-1}}}%
\nwixlogsorted{c}{{linking the drivers IO}{NW4Bsmdy-1zQ8wi-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-1zQ8wi-1}}}%
\nwixlogsorted{c}{{output linking}{NW4Bsmdy-47UBg5-1}{\nwixd{NW4Bsmdy-47UBg5-1}\nwixu{NW4Bsmdy-2o1CzV-1}}}%
\nwixlogsorted{c}{{Outputs}{NW4Bsmdy-2o1CzV-1}{\nwixu{NW4Bsmdy-439t7Z-1}\nwixd{NW4Bsmdy-2o1CzV-1}}}%
\nwixlogsorted{c}{{running the loop}{NW4Bsmdy-3sOZsM-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-3sOZsM-1}}}%
\nwixlogsorted{c}{{running the simulation}{NW4Bsmdy-3jYsn6-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-3jYsn6-1}}}%
\nwixlogsorted{c}{{S-function}{NW4Bsmdy-3Fygjc-1}{\nwixu{NW4Bsmdy-3TXSTG-1}\nwixd{NW4Bsmdy-3Fygjc-1}}}%
\nwixlogsorted{c}{{SAtmosphere}{NW4Bsmdy-4UUQgn-1}{\nwixu{NW4Bsmdy-3TXSTG-1}\nwixd{NW4Bsmdy-4UUQgn-1}}}%
\nwixlogsorted{c}{{Sensor abstract class}{NW4Bsmdy-1v0g0h-1}{\nwixd{NW4Bsmdy-1v0g0h-1}}}%
\nwixlogsorted{c}{{Server device parameter loading and formatting}{NW4Bsmdy-1ydhdJ-1}{\nwixd{NW4Bsmdy-1ydhdJ-1}\nwixu{NW4Bsmdy-439t7Z-3}}}%
\nwixlogsorted{c}{{Server methods}{NW4Bsmdy-srxv1-1}{\nwixu{NW4Bsmdy-439t7Z-3}\nwixd{NW4Bsmdy-srxv1-1}}}%
\nwixlogsorted{c}{{SGMT}{NW4Bsmdy-DzA6J-1}{\nwixu{NW4Bsmdy-3TXSTG-1}\nwixd{NW4Bsmdy-DzA6J-1}\nwixd{NW4Bsmdy-DzA6J-2}\nwixd{NW4Bsmdy-DzA6J-3}\nwixd{NW4Bsmdy-DzA6J-4}\nwixd{NW4Bsmdy-DzA6J-5}}}%
\nwixlogsorted{c}{{SGMT Start message}{NW4Bsmdy-H7a38-1}{\nwixd{NW4Bsmdy-H7a38-1}}}%
\nwixlogsorted{c}{{simceo}{NW4Bsmdy-oRqQe-1}{\nwixd{NW4Bsmdy-oRqQe-1}}}%
\nwixlogsorted{c}{{simceo.py}{NW4Bsmdy-3TXSTG-1}{\nwixd{NW4Bsmdy-3TXSTG-1}}}%
\nwixlogsorted{c}{{simceo.service}{NW4Bsmdy-14v388-1}{\nwixd{NW4Bsmdy-14v388-1}}}%
\nwixlogsorted{c}{{SOpticalPath}{NW4Bsmdy-rFcsf-1}{\nwixu{NW4Bsmdy-3TXSTG-1}\nwixd{NW4Bsmdy-rFcsf-1}\nwixd{NW4Bsmdy-rFcsf-2}\nwixd{NW4Bsmdy-rFcsf-3}\nwixd{NW4Bsmdy-rFcsf-4}\nwixd{NW4Bsmdy-rFcsf-5}\nwixd{NW4Bsmdy-rFcsf-6}\nwixd{NW4Bsmdy-rFcsf-7}}}%
\nwixlogsorted{c}{{SOpticalPath InitializeConditions message}{NW4Bsmdy-2zXOJO-1}{\nwixd{NW4Bsmdy-2zXOJO-1}\nwixd{NW4Bsmdy-2zXOJO-2}\nwixd{NW4Bsmdy-2zXOJO-3}}}%
\nwixlogsorted{c}{{SOpticalPath Outputs message}{NW4Bsmdy-34CYe8-1}{\nwixd{NW4Bsmdy-34CYe8-1}}}%
\nwixlogsorted{c}{{SOpticalPath Start message}{NW4Bsmdy-qPv2I-1}{\nwixd{NW4Bsmdy-qPv2I-1}}}%
\nwixlogsorted{c}{{SOpticalPath Terminate message}{NW4Bsmdy-8xvhs-1}{\nwixd{NW4Bsmdy-8xvhs-1}}}%
\nwixlogsorted{c}{{SOpticalPath Update message}{NW4Bsmdy-18W6Vx-1}{\nwixd{NW4Bsmdy-18W6Vx-1}\nwixd{NW4Bsmdy-18W6Vx-2}}}%
\nwixlogsorted{c}{{starting the drivers}{NW4Bsmdy-p2ZYp-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-p2ZYp-1}}}%
\nwixlogsorted{c}{{starting the simulation}{NW4Bsmdy-1ebFFG-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-1ebFFG-1}}}%
\nwixlogsorted{c}{{stepping through}{NW4Bsmdy-4CTiGt-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-4CTiGt-1}}}%
\nwixlogsorted{c}{{terminating the drivers}{NW4Bsmdy-1F7pYs-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-1F7pYs-1}}}%
\nwixlogsorted{c}{{terminating the simulation}{NW4Bsmdy-3UROtz-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-3UROtz-1}}}%
\nwixlogsorted{c}{{timing diagram}{NW4Bsmdy-xTFQY-1}{\nwixu{NW4Bsmdy-42xnBU-1}\nwixd{NW4Bsmdy-xTFQY-1}}}%
\nwixlogsorted{i}{{\nwixident{Atmosphere}}{Atmosphere}}%
\nwixlogsorted{i}{{\nwixident{Client}}{Client}}%
\nwixlogsorted{i}{{\nwixident{Driver}}{Driver}}%
\nwixlogsorted{i}{{\nwixident{exposure{\_}start}}{exposure:unstart}}%
\nwixlogsorted{i}{{\nwixident{exposure{\_}time}}{exposure:untime}}%
\nwixlogsorted{i}{{\nwixident{idx}}{idx}}%
\nwixlogsorted{i}{{\nwixident{Input}}{Input}}%
\nwixlogsorted{i}{{\nwixident{IO}}{IO}}%
\nwixlogsorted{i}{{\nwixident{Output}}{Output}}%
\nwixlogsorted{i}{{\nwixident{propagateThroughAtm}}{propagateThroughAtm}}%
\nwixlogsorted{i}{{\nwixident{sensor}}{sensor}}%
\nwixlogsorted{i}{{\nwixident{Server}}{Server}}%
\nwixlogsorted{i}{{\nwixident{src}}{src}}%
\nwixlogsorted{i}{{\nwixident{tie}}{tie}}%
\nwbegindocs{154}\nwdocspar

\section{Index} 
\nowebindex
\section{List of code chunks}
\nowebchunks
\nwenddocs{}
